
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Deep Learning with Dobble &#8212; Deep Learning for Experimental Psychologists and Cognitive Neuroscientists</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=384b581d" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="../../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=efea14e4"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=36754332"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-BXYWD71FWS"></script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-BXYWD71FWS');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-BXYWD71FWS');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'notebooks/student_projects/deep-learning-with-dobble';</script>
    <link rel="icon" href="../../_static/icon.png"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Python For Beginners" href="../python_course/beginners.html" />
    <link rel="prev" title="A3. Optimisation and Learning" href="../assignments/optimisation_learning.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo.png" class="logo__image only-light" alt="Deep Learning for Experimental Psychologists and Cognitive Neuroscientists - Home"/>
    <script>document.write(`<img src="../../_static/logo.png" class="logo__image only-dark" alt="Deep Learning for Experimental Psychologists and Cognitive Neuroscientists - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    Welcome
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Prerequisites</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../markdowns/environment_setup.html">0. Environment Setup</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../networks_building_blocks.html">1. Network’s Building Blocks</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../convolution.html">1.1. Convolution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../activation_function.html">1.2. Activation Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pooling.html">1.3. Pooling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linear.html">1.4. Linear Layer</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../quick_start.html">2. Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../optimisation_learning.html">3. Optimisation and Learning</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../vision.html">4. Vision</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../image_classification.html">4.1. Image Classification</a></li>





<li class="toctree-l2"><a class="reference internal" href="../image_segmentation.html">4.2. Image Segmentation</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../other_modalities.html">5. Other Modalities</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../audio_classification.html">5.1. Audio Classification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../text_classification.html">5.2. Text Classification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clip.html">5.3. Language – Vision</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../generative_models.html">6. Deep Generative Models</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../gan.html">6.1. Generative Adversarial Network</a></li>






<li class="toctree-l2"><a class="reference internal" href="../vae.html">6.2. Deep Autoencoder</a></li>







<li class="toctree-l2"><a class="reference internal" href="../dpm.html">6.3. Diffusion Probabilistic Model</a></li>






<li class="toctree-l2"><a class="reference internal" href="../llm.html">6.4. Large Language Model (LLM)</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../interpretation_techniques.html">7. Interpretation Techniques</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../activation.html">7.1. Activation Maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lesion.html">7.2. Kernel Lesioning</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linear_classifier_probe.html">7.3. Probing by linear classifiers</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../big_projects.html">8. Big Projects</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../markdowns/python_scripting.html">8.1. Python Scripting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tensorboard.html">8.2. TensorBoard</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../markdowns/server.html">8.3. Working with Servers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../reinforcement_learning.html">9. Reinforcement Learning</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Assignments</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../assignments/warmup.html">A1. Warming-up</a></li>
<li class="toctree-l1"><a class="reference internal" href="../assignments/dataloader.html">A2. Dataloaders</a></li>
<li class="toctree-l1"><a class="reference internal" href="../assignments/optimisation_learning.html">A3. Optimisation and Learning</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Student Projects</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Deep Learning with Dobble</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Complementary Materials</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../python_course/beginners.html">Python For Beginners</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-7"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../python_course/dataTypes.html">Data Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python_course/modules.html">Modules and NumPy Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python_course/conditions.html">Conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python_course/loops.html">Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python_course/plotting.html">Plotting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python_course/functions.html">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python_course/moduleObjects.html">Modules and Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python_course/inheritance.html">Inheritance</a></li>
</ul>
</li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://colab.research.google.com/github/DeepLearning-JupyterBook/deeplearning-jupyterbook.github.io/blob/master/notebooks/student_projects/deep-learning-with-dobble.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch onColab"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img src="../../_static/images/logo_colab.png">
  </span>
<span class="btn__text-container">Colab</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/DeepLearning-JupyterBook/deeplearning-jupyterbook.github.io" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/DeepLearning-JupyterBook/deeplearning-jupyterbook.github.io/edit/master//notebooks/student_projects/deep-learning-with-dobble.ipynb" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/DeepLearning-JupyterBook/deeplearning-jupyterbook.github.io/issues/new?title=Issue%20on%20page%20%2Fnotebooks/student_projects/deep-learning-with-dobble.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/notebooks/student_projects/deep-learning-with-dobble.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Deep Learning with Dobble</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#preparation">Preparation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#importing-packages">Importing Packages</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#downloading-checkpoints">Downloading Checkpoints</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-card-game-dobble-and-projective-planes">The Card Game Dobble and Projective Planes</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lines-in-the-euclidean-plane">Lines in the Euclidean Plane</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#adding-points-at-infinity">Adding Points at Infinity</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#finite-projective-planes-and-incidence-matrices">Finite Projective Planes and Incidence Matrices</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#further-reading">Further Reading</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-our-own-dobble-playing-cards">Creating our own Dobble Playing Cards</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#empty-playing-cards">Empty Playing Cards</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#emojis">Emojis</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#circle-packing">Circle Packing</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#finite-projective-planes">Finite Projective Planes</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dobble-decks">Dobble Decks</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pairs-of-cards">Pairs of Cards</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#setting-up-a-deep-learning-pipeline">Setting up a Deep Learning Pipeline</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#generating-datasets">Generating Datasets</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#utility-functions">Utility Functions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#learning-rate-schedule-rex">Learning Rate Schedule REX</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#training-and-testing-routines">Training and Testing Routines</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#transforming-and-augmenting-images">Transforming and Augmenting Images</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#resnet-models-of-different-depths">ResNet Models of Different Depths</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#parameters-and-preparation">Parameters and Preparation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#resnet-18">ResNet-18</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#remaining-resnet-models">Remaining ResNet Models</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <p><a class="reference external" href="https://colab.research.google.com/github/mrvnthss/deep-learning-with-dobble/blob/main/deep-learning-with-dobble.ipynb"><img alt="Open in Colab" src="https://colab.research.google.com/assets/colab-badge.svg" /></a></p>
<section class="tex2jax_ignore mathjax_ignore" id="deep-learning-with-dobble">
<h1>Deep Learning with Dobble<a class="headerlink" href="#deep-learning-with-dobble" title="Link to this heading">#</a></h1>
<p><strong>GitHub</strong>: <a class="github reference external" href="https://github.com/mrvnthss/deep-learning-with-dobble">mrvnthss/deep-learning-with-dobble</a></p>
<p><strong>Purpose</strong>: A deep learning project based on the card game <em>Dobble</em>, implemented in PyTorch.</p>
<p><strong>Context</strong>: Graded hands-on project as part of the <em>Deep Learning</em> Seminar at the <a class="reference external" href="https://www.uni-giessen.de">University of Giessen</a></p>
<p><strong>Authors</strong>: 2024 Marvin Theiss, Nina Winkelmann</p>
<p><strong>License</strong>: <a class="reference external" href="https://www.gnu.org/licenses/gpl-3.0.html">GNU General Public License v3</a></p>
<section id="preparation">
<h2>Preparation<a class="headerlink" href="#preparation" title="Link to this heading">#</a></h2>
<section id="importing-packages">
<h3>Importing Packages<a class="headerlink" href="#importing-packages" title="Link to this heading">#</a></h3>
<p>Before we start, we import all the packages that we’ll be using later on. We follow the recommended order of ordering imports in Python, i.e.,</p>
<ol class="arabic simple">
<li><p>standard library imports</p></li>
<li><p>third-party library imports</p></li>
<li><p>local imports (not applicable here)</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span><span class="p">,</span> <span class="n">ImageDraw</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">from</span> <span class="nn">torchvision</span> <span class="kn">import</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">models</span>
<span class="kn">from</span> <span class="nn">torchvision.transforms</span> <span class="kn">import</span> <span class="n">v2</span> <span class="k">as</span> <span class="n">transforms</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="downloading-checkpoints">
<h3>Downloading Checkpoints<a class="headerlink" href="#downloading-checkpoints" title="Link to this heading">#</a></h3>
<p>We also need to download some checkpoints and move them into the appropriate directory.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">MODELS_DIR</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;models&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p><strong>Important</strong>: Together, the checkpoints make up 1.34 GB. Depending on your connection, downloading these may take a while.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;https://dl.dropboxusercontent.com/scl/fi/e9r8kppvzrgt8jt6d8zi2/models.tar.gz?rlkey=q49hftmdwgwm2yc4njpy6f094&#39;</span>
<span class="n">datasets</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">download_and_extract_archive</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">download_root</span><span class="o">=</span><span class="n">MODELS_DIR</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;models.tar.gz&#39;</span><span class="p">,</span> <span class="n">remove_finished</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Downloading https://dl.dropboxusercontent.com/scl/fi/e9r8kppvzrgt8jt6d8zi2/models.tar.gz?rlkey=q49hftmdwgwm2yc4njpy6f094 to models/models.tar.gz
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>100.0%
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Extracting models/models.tar.gz to models
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="the-card-game-dobble-and-projective-planes">
<h2>The Card Game Dobble and Projective Planes<a class="headerlink" href="#the-card-game-dobble-and-projective-planes" title="Link to this heading">#</a></h2>
<p><a class="reference external" href="https://www.dobblegame.com/en/homepage/"><em>Dobble</em></a> is a <strong>popular card game</strong> that challenges players to spot matching symbols between pairs of cards. It was created by <em>Denis Blanchot</em> and <em>Jacques Cottereau</em> and has gained significant popularity due to its simple yet engaging gameplay.</p>
<div style="text-align: center">
    <figure>
        <img src="https://github.com/mrvnthss/deep-learning-with-dobble/blob/main/reports/other/dobble-brettspiel-empfehlungen.jpg?raw=true" alt="card-game-dobble" width="700">
        <br>
        <figcaption style="text-align: center">
            A set of <em>Dobble</em> cards. <a href="https://brettspiel-empfehlungen.de">&copy; 2024 Brettspiel Empfehlungen</a>. Used with permission.
        </figcaption>
    </figure>
</div>
<p>At first glance, a deck of <em>Dobble</em> playing cards may just seem like a collection of cards with symbols randomly printed on them. However, a full deck of playing cards consists of 55 playing cards where every single playing card features 8 out of 57 distinct symbols in such a way that <strong>each pair of cards</strong> (no matter which pair you choose!) <strong>shares exactly one symbol</strong>. If you pause to think for a moment, it is by no means obvious that it should be possible to construct such a deck of playing cards in the first place! The reason we know that this must be possible is that a deck of <em>Dobble</em> playing cards can be interpreted as a mathematical structure called a <strong>finite projective plane</strong>. A what, you ask? Let’s take it one step at a time, starting with a concept that many of us will remember from high school: lines in the Euclidean plane.</p>
<section id="lines-in-the-euclidean-plane">
<h3>Lines in the Euclidean Plane<a class="headerlink" href="#lines-in-the-euclidean-plane" title="Link to this heading">#</a></h3>
<p>Surely, you’re familiar with a linear system of equations in two variables, i.e., something like this:</p>
<p>\begin{align*}
a_{11} x_1 + a_{12} x_2 &amp;= b_1 \
a_{21} x_1 + a_{22} x_2 &amp;= b_2
\end{align*}</p>
<p>By rearranging these equations, we see that each equation describes a unique line in the Euclidean plane. For example, we can rewrite the first equation as</p>
<div class="math notranslate nohighlight">
\[
x_2 = - a_{11} x_1 + b_1 ,
\]</div>
<p>which describes a line with slope <span class="math notranslate nohighlight">\(- a_{11}\)</span> and <span class="math notranslate nohighlight">\(y\)</span>-intercept <span class="math notranslate nohighlight">\(b_1\)</span>. From this point of view, the solution(s) of the linear system is/are simply the intersection point(s) of the two lines. There are three possible outcomes:</p>
<ol class="arabic simple">
<li><p>The two lines are parallel (and distinct) so that they do not intersect at all.</p></li>
<li><p>The two lines intersect in exactly one point <span class="math notranslate nohighlight">\((x_0, y_0)\)</span>.</p></li>
<li><p>The two lines are identical and intersect in infinitely many points.</p></li>
</ol>
<p>The following figure illustrates these three different scenarios:</p>
<div style="text-align: center">
	<figure>
    	<img src="https://www.mathsisfun.com/algebra/images/system-linear-types.svg" alt="linear-system" width="500">
    	<br>
    	<figcaption style="text-align: center">
    		Possible scenarios for a linear system in two variables. <a href="https://www.mathsisfun.com/algebra/systems-linear-equations.html">© 2023 Rod Pierce</a>. Used with permission.
    	</figcaption>
	</figure>
</div>
<p>By focusing on <em>distinct</em> lines, we get rid of the third case (as that is just the intersection of a line <em>with itself</em>). However, this still doesn’t solve the problem of two parallel lines.</p>
</section>
<section id="adding-points-at-infinity">
<h3>Adding Points at Infinity<a class="headerlink" href="#adding-points-at-infinity" title="Link to this heading">#</a></h3>
<p>Can’t we just <em>force</em> these parallel lines to intersect somehow? Yes, we can! Loosely speaking, we simly make up additional <em>points at infinity</em>, and then declare that parallel lines intersect at these made-up points. That doesn’t sound convincing to you? That’s pretty much what projective planes are (well, loosely speaking at least). Here is the precise mathematical definition, taken from <a class="reference external" href="https://en.wikipedia.org/wiki/Projective_plane#Definition">Wikipedia</a>:</p>
<blockquote>
<div><p>A <strong>projective plane</strong> consists of a set of lines, a set of points, and a relation between points and lines called <strong>incidence</strong>, having the following properties:</p>
<ol class="arabic simple">
<li><p>Given any two distinct points, there is exactly one line incident with both of them.</p></li>
<li><p>Given any two distinct lines, there is exactly one point incident with both of them.</p></li>
<li><p>There are four points such that no line is incident with more than two of them.</p></li>
</ol>
</div></blockquote>
<p>For the sake of understanding, you can think of points and lines being “incident” with each other as a point being on a line or a line passing through a point. The term “incident” is only used to highlight the symmetric relationship between points and lines of a projective plane. Also, the third condition is a technicality to rule out so-called <em>degenerate</em> cases that aren’t interesting from a mathematical perspective. In case you’re curious, here are examples of degenerate projective planes:</p>
<div style="text-align: center">
    <figure>
        <img src="https://upload.wikimedia.org/wikipedia/en/8/81/Degenerate_planes_wec.svg" alt="degenerate-cases" width="300">
        <br>
        <figcaption style="text-align: center">
            Non-empty degenerate projective planes. <a href="https://creativecommons.org/publicdomain/zero/1.0/deed.en"> CC0</a>.
        </figcaption>
    </figure>
</div>
<p>Let’s figure out what the first two conditions imply in terms of a deck of <em>Dobble</em> playing cards. We can think of playing cards representing the lines and symbols representing the points of a projective plane. We start with the first condition:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Given any two distinct points, there is exactly one line incident with both of them.</p></li>
</ol>
</div></blockquote>
<p>This implies that, if we randomly pick two symbols from all symbols available, we will find exactly one playing card featuring both of these symbols. Why is this necessary? Let’s assume that the opposite was true, i.e., we could find at least two cards both featuring the same two symbols. This clearly contradicts the fact that each pair of <em>Dobble</em> cards shares <em>only one</em> symbol. Note that this condition also rules out the possibility that there is a pair of symbols that does not appear on <em>any</em> playing card. As a matter of fact, this is acutally the case for a deck of <em>Dobble</em> playing cards. However, this is only due to the fact that, for some reason, the full deck only includes 55 of the 57 possible different playing cards. Now, let’s look at the second condition.</p>
<blockquote>
<div><ol class="arabic simple" start="2">
<li><p>Given any two distinct lines, there is exactly one point incident with both of them.</p></li>
</ol>
</div></blockquote>
<p>This guarantees that, if we choose any two cards from a deck of playing cards, these two cards will share one (and only one) symbol between them.</p>
</section>
<section id="finite-projective-planes-and-incidence-matrices">
<h3>Finite Projective Planes and Incidence Matrices<a class="headerlink" href="#finite-projective-planes-and-incidence-matrices" title="Link to this heading">#</a></h3>
<p>Finite projective planes are exactly what you’d expect them to be: they’re projective planes that consist of only finitely many points and lines. For a finite projective plane, one can show that there exists an integer <span class="math notranslate nohighlight">\(N\)</span> called the <strong>order</strong> of the projective plane such that…</p>
<ul class="simple">
<li><p>the number of points and lines is given by <span class="math notranslate nohighlight">\(N^2 + N + 1\)</span>,</p></li>
<li><p>there are <span class="math notranslate nohighlight">\(N + 1\)</span> points on each line,</p></li>
<li><p>there are <span class="math notranslate nohighlight">\(N + 1\)</span> lines passing through each point.</p></li>
</ul>
<p>In particular, every projective plane (finite or infinite) has as many points as it has lines. Before we move on, let’s take a look at some examples. First, here is an illustration of a finite projective plane of order 3:</p>
<div style="text-align: center">
    <figure>
        <img src="https://i2.wp.com/puzzlewocky.com/wp-content/uploads/2018/01/ProjectivePlaneOrder3.jpg?w=750&ssl=1" alt="projective-plane-order-3" width="300">
        <br>
        <figcaption style="text-align: center">
            A finite projective plane of order 3. <a href="https://puzzlewocky.com/math-fun/from-orthogonal-latin-squares-to-finite-projective-planes/"> &copy; 2024 Brendan Conley</a>.
        </figcaption>
    </figure>
</div>
<p>The same projective plane can also be illustrated in a symmetric fashion:</p>
<div style="text-align: center">
    <figure>
        <img src="https://i0.wp.com/puzzlewocky.com/wp-content/uploads/2018/01/SymmetricalProjectivePlaneOrder3.jpg?w=770&ssl=1" alt="projective-plane-order-3" width="250">
        <br>
        <figcaption style="text-align: center">
            A finite projective plane of order 3. <a href="https://puzzlewocky.com/math-fun/from-orthogonal-latin-squares-to-finite-projective-planes/"> &copy; 2024 Brendan Conley</a>.
        </figcaption>
    </figure>
</div>
<p>Finally, here is a projective plane of order 4:</p>
<div style="text-align: center">
    <figure>
        <img src="https://i1.wp.com/puzzlewocky.com/wp-content/uploads/2016/02/pporder4.jpg?w=471&ssl=1" alt="projective-plane-order-3" width="300">
        <br>
        <figcaption style="text-align: center">
            A finite projective plane of order 4. <a href="https://puzzlewocky.com/games/the-math-of-spot-it/"> &copy; 2024 Brendan Conley</a>.
        </figcaption>
    </figure>
</div>
<p>Finite projective planes provide the added benefit that they can be represented by and constructed from so-called <strong>incidence matrices</strong>. An incident matrix is simply a matrix where the rows correspond to lines and the columns correspond to points such that the entry associated with a given line-point-pair indicates whether this line and point are incident. Here is an example of an incidence matrix of a finite projective plane of order 3:</p>
<div style="text-align: center">
    <figure>
        <img src="https://miro.medium.com/v2/resize:fit:1400/1*gZY9SSoO-LHFSHAw1ENY5Q.png" alt="incidence-matrix" width="300">
        <br>
        <figcaption style="text-align: center">
            The incidence matrix of a finite projective plane of order 3. <a href="https://mickydore.medium.com/dobble-theory-and-implementation-ff21ddbb5318"> &copy; 2021 Micky Dore</a>.
        </figcaption>
    </figure>
</div>
<p>The incidence matrices of finite projective planes of order <span class="math notranslate nohighlight">\(N = p^k\)</span> with <span class="math notranslate nohighlight">\(p\)</span> prime (i.e., <span class="math notranslate nohighlight">\(N\)</span> is a <em>prime power</em>) can be computed algorithmically, and this is exactly what we’ll do later on to construct our own decks of <em>Dobble</em> playing cards. Interestingly, the order of all <em>known</em> finite projective planes is a prime power, and the existence of finite projective planes of orders that are not a prime-power is still an open research question.</p>
</section>
<section id="further-reading">
<h3>Further Reading<a class="headerlink" href="#further-reading" title="Link to this heading">#</a></h3>
<p>There are several well-written articles on the internet covering the mathematical underpinnings of <em>Dobble</em> in even greater detail than what we have discussed here. If you’re interested to learn more, here is a non-exhaustive list:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://mickydore.medium.com/dobble-theory-and-implementation-ff21ddbb5318">The maths behind Dobble</a> by <em>Micky Dore</em></p></li>
<li><p><a class="reference external" href="https://mickydore.medium.com/the-dobble-algorithm-b9c9018afc52">The Dobble algorithm</a> by <em>Micky Dore</em></p></li>
<li><p><a class="reference external" href="https://puzzlewocky.com/games/the-math-of-spot-it/">Finite projective planes and the math of Spot It!</a> on <em><a class="reference external" href="http://puzzlewocky.com">puzzlewocky.com</a></em></p></li>
<li><p><a class="reference external" href="https://www.petercollingridge.co.uk/blog/mathematics-toys-and-games/dobble/">Dobble</a> by <em>Peter Collingridge</em></p></li>
<li><p><a class="reference external" href="https://unipub.uni-graz.at/obvugrhs/download/pdf/6499156?originalFilename=true">Ein Einblick in die Mathematik hinter dem Kartenspiel Dobble</a> by <em>Christian Kathrein</em> [in German]</p></li>
</ul>
</section>
</section>
<section id="creating-our-own-dobble-playing-cards">
<h2>Creating our own Dobble Playing Cards<a class="headerlink" href="#creating-our-own-dobble-playing-cards" title="Link to this heading">#</a></h2>
<p>Essentially, there are (at least) two alternatives to generate the data needed to train a network so that it learns to play the card game <em>Dobble</em>. Either, one purchases (or already owns) the actual game and takes pictures of all of the individual cards, or one generates their own <em>Dobble</em> playing cards from scratch. For this project, we chose the second option, i.e., we decided to generate images of custom <em>Dobble</em> cards using popular image-processing libraries such as <a class="reference external" href="https://pypi.org/project/opencv-python/">OpenCV</a> and <a class="reference external" href="https://pypi.org/project/Pillow/">Pillow</a>.</p>
<p>This approach has several <em>advantages</em>, so let’s just highlight a few of these:</p>
<ul class="simple">
<li><p><strong>Multiple decks of cards</strong>: Instead of being stuck with a single deck of cards, we can (theoretically) generate infinitely many different sets.</p></li>
<li><p><strong>Full control over the dataset</strong>: We can control every last detail of our <em>Dobble</em> cards. For example, we can control the color of the individual symbols, their size, their placement on the card, and so on.</p></li>
<li><p><strong>Easier data generation</strong>: When working with networks, we aim to feed images of pairs of cards into the networks and then ask the networks to find the unique symbol that is present on both cards. For a classic deck of <em>Dobble</em> cards, there are 1,596 possible combinations of cards. Manually taking pictures of all of these pairs of cards would be immensely time-consuming. On the contrary, generating images of pairs of cards is straightforward once all of the individual cards have been created.</p></li>
</ul>
<p><strong>Here’s how we will go about creating our datasets</strong>:
First, we need to generate images of individual cards. To do so, we first have to create <strong>empty playing cards</strong>. This is going to be easy as this equates to generating square images of a white disk against a transparent background. Next, we need to find an <strong>open-source library of emojis</strong> that we can use as the symbols on our <em>Dobble</em> cards. Once we have that, we need to find a way to <strong>place</strong> these <strong>individual emojis</strong> onto the empty playing cards without having emojis overlap. If possible, we want to replicate the way that the symbols are arranged on actual <em>Dobble</em> cards: The centers of the individual symbols vary across cards and so do the sizes of the symbols. After we have implemented the necessary algorithms to achieve this, we are in the position to <strong>generate individual <em>Dobble</em>-like playing cards</strong>. Next, we need to come up with an algorithm that tells us <strong>which emojis to place on which card</strong> so that every two cards will share one and only one common emoji. Essentially, this boils down to implementing an algorithm that computes the incidence matrix of a finite projective plane of a given order. Given such an algorithm we can <strong>systematically create all the cards</strong> that make up a full deck of <em>Dobble</em> playing cards. Finally, we need to <strong>find all pairs of cards</strong>, which will serve as the dataset(s) for our project.</p>
<p>Let’s start by implementing a function that returns an empty playing card. This should be easy.</p>
<section id="empty-playing-cards">
<h3>Empty Playing Cards<a class="headerlink" href="#empty-playing-cards" title="Link to this heading">#</a></h3>
<p>As just mentioned, the starting point for our custom <em>Dobble</em> playing cards will be square images consisting of nothing but a white disk against a transparent background.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_empty_card</span><span class="p">(</span>
        <span class="n">image_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">return_pil</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Image</span><span class="o">.</span><span class="n">Image</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a square image of a white disk against a transparent background.</span>

<span class="sd">    Args:</span>
<span class="sd">        image_size (int): The size of the square image in pixels.</span>
<span class="sd">        return_pil (bool): Whether to return a PIL Image (True) or a NumPy array (False).  Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Image.Image or np.ndarray: The generated image of a white disk against a transparent background.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create a new transparent image with RGBA mode</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;RGBA&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">image_size</span><span class="p">,</span> <span class="n">image_size</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c1"># Create a new draw object and draw a white disk onto the image</span>
    <span class="n">draw</span> <span class="o">=</span> <span class="n">ImageDraw</span><span class="o">.</span><span class="n">Draw</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="n">draw</span><span class="o">.</span><span class="n">ellipse</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_size</span><span class="p">,</span> <span class="n">image_size</span><span class="p">),</span> <span class="n">fill</span><span class="o">=</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">image</span> <span class="k">if</span> <span class="n">return_pil</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s check out what this looks like. To actually see the white disk, we make the transparent background fully opaque.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">image_size</span> <span class="o">=</span> <span class="mi">1024</span>
<span class="n">empty_playing_card</span> <span class="o">=</span> <span class="n">create_empty_card</span><span class="p">(</span><span class="n">image_size</span><span class="p">,</span> <span class="n">return_pil</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">empty_playing_card</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>

<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">empty_playing_card</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;An Empty Playing Card&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/6b3aa2d6a039b0a45429576d682596ad775372aebc984dbfa5de18b4df8e7088.png" src="../../_images/6b3aa2d6a039b0a45429576d682596ad775372aebc984dbfa5de18b4df8e7088.png" />
</div>
</div>
<p>Now, let’s move on to the fun part: emojis.</p>
</section>
<section id="emojis">
<h3>Emojis<a class="headerlink" href="#emojis" title="Link to this heading">#</a></h3>
<p>The emojis for this project are taken from <a class="reference external" href="https://openmoji.org">OpenMoji</a> and are free to use under the <a class="reference external" href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> license, which is compatible with the <a class="reference external" href="https://www.gnu.org/licenses/gpl-3.0.en.html">GNU General Public License v3</a>. Information on the compatibility of <em>CC BY-SA 4.0</em> with <em>GPLv3</em> can be found <a class="reference external" href="https://creativecommons.org/share-your-work/licensing-considerations/compatible-licenses">here</a>.</p>
<p>We have manually downloaded the emojis and placed them into the following directory (relative to this notebook): <code class="docutils literal notranslate"><span class="pre">data/external/emojis/classic-dobble/</span></code>. Inside this directory, there are two subdirectories called <code class="docutils literal notranslate"><span class="pre">color</span></code> and <code class="docutils literal notranslate"><span class="pre">outline</span></code>. These contain the colored versions of the emojis and just their outlines, respectively.</p>
<p><strong>Note</strong>: The directory <code class="docutils literal notranslate"><span class="pre">data/external/emojis/</span></code> is the general directory where we will store different sets of emojis (e.g., animals, food, etc.). Each of these sets should then include the two subdirectories <code class="docutils literal notranslate"><span class="pre">color</span></code> and <code class="docutils literal notranslate"><span class="pre">outline</span></code> containing the corresponding images.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">EMOJIS_DIR</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;data/external/emojis&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We have curated a set of emojis that is (somewhat) close to the images used in the original <em>Dobble</em> card game. Before we move on, we download this set of emojis along with some data on circle packings that we’ll turn to later.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;https://dl.dropboxusercontent.com/scl/fi/stwr2l6zxjz70nfyfzhyh/external.tar.gz?rlkey=su4p0xlhx774mjqfum3duvdaw&#39;</span>
<span class="n">datasets</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">download_and_extract_archive</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">download_root</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;external.tar.gz&#39;</span><span class="p">,</span> <span class="n">remove_finished</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Downloading https://dl.dropboxusercontent.com/scl/fi/stwr2l6zxjz70nfyfzhyh/external.tar.gz?rlkey=su4p0xlhx774mjqfum3duvdaw to data/external.tar.gz
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>100.0%
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Extracting data/external.tar.gz to data
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</div>
<p>To create our playing cards, we will need to be able to <strong>obtain the names of all emojis available in a given set</strong> of emojis (i.e., directory) at once. Let’s implement a function that does just that.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_emoji_names</span><span class="p">(</span>
        <span class="n">emoji_set</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">outline_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Retrieve the names of all emojis in the specified set of emojis.</span>

<span class="sd">    Args:</span>
<span class="sd">        emoji_set (str): The name of the emoji set to use (e.g., &#39;classic-dobble&#39;).</span>
<span class="sd">        outline_only (bool): Specifies whether to retrieve names of emojis with outline only.  Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list[str]: A list of names of all emojis in the specified set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dir_path</span> <span class="o">=</span> <span class="n">EMOJIS_DIR</span> <span class="o">/</span> <span class="n">emoji_set</span> <span class="o">/</span> <span class="p">(</span><span class="s1">&#39;outline&#39;</span> <span class="k">if</span> <span class="n">outline_only</span> <span class="k">else</span> <span class="s1">&#39;color&#39;</span><span class="p">)</span>

    <span class="n">emoji_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">file_path</span> <span class="ow">in</span> <span class="n">dir_path</span><span class="o">.</span><span class="n">iterdir</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">file_path</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s1">&#39;.png&#39;</span><span class="p">:</span>
            <span class="c1"># Extract the base name without extension (i.e., without &#39;.png&#39;)</span>
            <span class="n">emoji_name</span> <span class="o">=</span> <span class="n">file_path</span><span class="o">.</span><span class="n">stem</span>
            <span class="n">emoji_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">emoji_name</span><span class="p">)</span>
    <span class="n">emoji_names</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">emoji_names</span>
</pre></div>
</div>
</div>
</div>
<p>To make sure that this function works as expected, let’s print the names of all the emojis of the <code class="docutils literal notranslate"><span class="pre">classic-dobble</span></code> set.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">classic_dobble_emoji_names</span> <span class="o">=</span> <span class="n">get_emoji_names</span><span class="p">(</span><span class="s1">&#39;classic-dobble&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">classic_dobble_emoji_names</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>anchor
baby-bottle
bison
bomb
cactus
candle
carrot
cheese-wedge
chess-pawn
clown-face
deciduous-tree
dog-face
dragon
droplet
drunk-person
eye
fire
four-leaf-clover
ghost
green-apple
grinning-cat-with-smiling-eyes
hammer
hand-with-fingers-splayed
heart
high-heeled-shoe
high-voltage
ice
key
lady-beetle
last-quarter-moon-face
light-bulb
locked
maple-leaf
microbe
mount-fuji
mouth
musical-score
oncoming-police-car
pencil
red-exclamation-mark
red-question-mark
rosette
scissors
skull-and-crossbones
snowflake
snowman-without-snow
spider
spider-web
spouting-whale
stop-sign
sun-with-face
sunglasses
t-rex
timer
turtle
twitter
yin-yang
</pre></div>
</div>
</div>
</div>
<p>Next, we need a function that takes as input the name of the set of emojis (e.g., <code class="docutils literal notranslate"><span class="pre">classic-dobble</span></code>) as well as the name of the emoji (e.g., <code class="docutils literal notranslate"><span class="pre">dog-face</span></code>) and then <strong>loads the corresponding emoji image into memory</strong> and returns it.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_emoji</span><span class="p">(</span>
        <span class="n">emoji_set</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">emoji_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">outline_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_pil</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Image</span><span class="o">.</span><span class="n">Image</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load an emoji from the specified set of emojis.</span>

<span class="sd">    Args:</span>
<span class="sd">        emoji_set (str): The name of the set of emojis (e.g., &#39;classic-dobble&#39;).</span>
<span class="sd">        emoji_name (str): The name of the emoji to load.</span>
<span class="sd">        outline_only (bool): Whether to load the outline-only version of the emoji.  Defaults to False.</span>
<span class="sd">        return_pil (bool): Whether to return a PIL Image (True) or a NumPy array (False).  Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Image.Image or np.ndarray: The loaded emoji image.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the specified emoji file is not found or is not a valid PNG file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create the file path pointing to the emoji that we want to load</span>
    <span class="n">which_type</span> <span class="o">=</span> <span class="s1">&#39;outline&#39;</span> <span class="k">if</span> <span class="n">outline_only</span> <span class="k">else</span> <span class="s1">&#39;color&#39;</span>
    <span class="n">file_path</span> <span class="o">=</span> <span class="n">EMOJIS_DIR</span> <span class="o">/</span> <span class="n">emoji_set</span> <span class="o">/</span> <span class="n">which_type</span> <span class="o">/</span> <span class="p">(</span><span class="n">emoji_name</span> <span class="o">+</span> <span class="s1">&#39;.png&#39;</span><span class="p">)</span>

    <span class="c1"># Check if the file exists and verify that it is a valid PNG file</span>
    <span class="k">if</span> <span class="n">file_path</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Verify that the file is a valid PNG file, then load it</span>
            <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span><span class="o">.</span><span class="n">verify</span><span class="p">()</span>
            <span class="n">emoji_image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>

            <span class="c1"># Convert to RGBA mode if necessary</span>
            <span class="k">if</span> <span class="n">emoji_image</span><span class="o">.</span><span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;RGBA&#39;</span><span class="p">:</span>
                <span class="n">emoji_image</span> <span class="o">=</span> <span class="n">emoji_image</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s1">&#39;RGBA&#39;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">emoji_image</span> <span class="k">if</span> <span class="n">return_pil</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">emoji_image</span><span class="p">)</span>

        <span class="k">except</span> <span class="p">(</span><span class="ne">IOError</span><span class="p">,</span> <span class="ne">SyntaxError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Failed to load emoji: </span><span class="si">{</span><span class="n">file_path</span><span class="si">}</span><span class="s1"> is not a valid PNG file.&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Failed to load emoji: </span><span class="si">{</span><span class="n">file_path</span><span class="si">}</span><span class="s1"> does not exist.&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s use this function to visualize all the emojis in the <code class="docutils literal notranslate"><span class="pre">classic-dobble</span></code> set.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;reports/figures/emojis/classic-dobble-emojis.png&#39;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">classic_dobble_emoji_names</span><span class="p">):</span>  <span class="c1"># Check if there are still emojis remaining</span>
        <span class="n">emoji_image_np</span> <span class="o">=</span> <span class="n">load_emoji</span><span class="p">(</span><span class="s1">&#39;classic-dobble&#39;</span><span class="p">,</span> <span class="n">classic_dobble_emoji_names</span><span class="p">[</span><span class="n">count</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">emoji_image_np</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Emojis in the Classic Dobble Deck&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">file_path</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">file_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/a971cbf9495564b9ef56b72a3737c6a58de986dd4af79af43639d9e0ca923520.png" src="../../_images/a971cbf9495564b9ef56b72a3737c6a58de986dd4af79af43639d9e0ca923520.png" />
</div>
</div>
<p>Next, we write a function that <strong>manipulates the size of each emoji</strong> in such a way that all image content is within the circle that’s inscribed in the square made up of the square image. It will become apparent later why this is useful.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rescale_emoji</span><span class="p">(</span>
        <span class="n">emoji_image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.99</span><span class="p">,</span>
        <span class="n">return_pil</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Image</span><span class="o">.</span><span class="n">Image</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Rescale an emoji so that it fits inside the circle inscribed in the square image.</span>

<span class="sd">    Args:</span>
<span class="sd">        emoji_image (np.ndarray): The emoji image to rescale as a NumPy array.</span>
<span class="sd">        scale (float): Determines to what extent the emoji should fill the inscribed circle.  Defaults to 0.99.</span>
<span class="sd">        return_pil (bool): Whether to return a PIL Image (True) or a NumPy array (False).  Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Image.Image or np.ndarray: The rescaled emoji image.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the &#39;emoji_image&#39; is not a NumPy array or not a square image.</span>
<span class="sd">        ValueError: If the &#39;scale&#39; is not in the range of (0, 1].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure that the input image is a NumPy array</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">emoji_image</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Emoji image is not a NumPy array.&#39;</span><span class="p">)</span>

    <span class="c1"># Ensure that the input image is a square image</span>
    <span class="k">if</span> <span class="n">emoji_image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">emoji_image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input image must be a square array.&#39;</span><span class="p">)</span>

    <span class="c1"># Check if scale is within the range of (0, 1]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">scale</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Scale must be in the range of (0, 1].&#39;</span><span class="p">)</span>
    
    <span class="c1"># Determine non-transparent pixels</span>
    <span class="n">non_transparent_px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">emoji_image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Transform coordinates so that center pixel corresponds to origin of Euclidean plane</span>
    <span class="c1"># NOTE: The y-axis is flipped here, which doesn&#39;t matter for computing the Euclidean norm</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="n">emoji_image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">non_transparent_px</span> <span class="o">-=</span> <span class="n">radius</span>
    
    <span class="c1"># Determine the maximum Euclidean norm of all non-transparent pixels</span>
    <span class="n">outermost_px_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">non_transparent_px</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Compute rescaling factor and resulting target size</span>
    <span class="n">target_norm</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">radius</span>
    <span class="n">rescaling_factor</span> <span class="o">=</span> <span class="n">target_norm</span> <span class="o">/</span> <span class="n">outermost_px_norm</span>
    <span class="n">image_size</span> <span class="o">=</span> <span class="n">emoji_image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># size of input image</span>
    <span class="n">target_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">image_size</span> <span class="o">*</span> <span class="n">rescaling_factor</span><span class="p">)</span>  <span class="c1"># target size of rescaled image</span>
    
    <span class="c1"># Convert to PIL Image and rescale</span>
    <span class="n">emoji_image_pil</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">emoji_image</span><span class="p">)</span>
    <span class="n">emoji_image_pil</span> <span class="o">=</span> <span class="n">emoji_image_pil</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="n">target_size</span><span class="p">,</span> <span class="n">target_size</span><span class="p">),</span> <span class="n">Image</span><span class="o">.</span><span class="n">LANCZOS</span><span class="p">)</span>

    <span class="c1"># Compute offset for centering/cropping the rescaled image</span>
    <span class="c1"># NOTE: Taking the absolute value handles both cases (i.e., rescaling_factor &lt; 1 and rescaling_factor &gt; 1)</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">target_size</span> <span class="o">-</span> <span class="n">image_size</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">rescaling_factor</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Paste rescaled (smaller) image onto fully transparent image of original size</span>
        <span class="n">rescaled_image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;RGBA&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">image_size</span><span class="p">,</span> <span class="n">image_size</span><span class="p">),</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">rescaled_image</span><span class="o">.</span><span class="n">paste</span><span class="p">(</span><span class="n">emoji_image_pil</span><span class="p">,</span> <span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">offset</span><span class="p">),</span> <span class="n">mask</span><span class="o">=</span><span class="n">emoji_image_pil</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">rescaling_factor</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Compute coordinates for cropping</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="n">image_size</span>
        <span class="n">bottom</span> <span class="o">=</span> <span class="n">top</span> <span class="o">+</span> <span class="n">image_size</span>
    
        <span class="c1"># Crop rescaled (larger) image</span>
        <span class="n">rescaled_image</span> <span class="o">=</span> <span class="n">emoji_image_pil</span><span class="o">.</span><span class="n">crop</span><span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">bottom</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Return original image</span>
        <span class="n">rescaled_image</span> <span class="o">=</span> <span class="n">emoji_image_pil</span>

    <span class="k">return</span> <span class="n">rescaled_image</span> <span class="k">if</span> <span class="n">return_pil</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rescaled_image</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s see the effect of the <code class="docutils literal notranslate"><span class="pre">rescale_emoji</span></code> function on an emoji that originally extends outside the inscribed circle.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load &#39;bomb&#39; emoji</span>
<span class="n">bomb_np</span> <span class="o">=</span> <span class="n">load_emoji</span><span class="p">(</span><span class="s1">&#39;classic-dobble&#39;</span><span class="p">,</span> <span class="s1">&#39;bomb&#39;</span><span class="p">)</span>

<span class="n">bomb_pil</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">bomb_np</span><span class="p">)</span>
<span class="n">bomb_rescaled_pil</span> <span class="o">=</span> <span class="n">rescale_emoji</span><span class="p">(</span><span class="n">bomb_np</span><span class="p">)</span>
<span class="n">images</span> <span class="o">=</span> <span class="p">[</span><span class="n">bomb_pil</span><span class="p">,</span> <span class="n">bomb_rescaled_pil</span><span class="p">]</span>

<span class="c1"># Prepare subplot</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;reports/figures/emojis/downsized-emoji.png&#39;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>

    <span class="n">image_size</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">draw</span> <span class="o">=</span> <span class="n">ImageDraw</span><span class="o">.</span><span class="n">Draw</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="n">draw</span><span class="o">.</span><span class="n">ellipse</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_size</span><span class="p">,</span> <span class="n">image_size</span><span class="p">),</span> <span class="n">outline</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Original&#39;</span> <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;Rescaled&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Downsizing Emojis&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">file_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/6bbf902247bd6146c58ff00c41c0f66ce9e48e3d8a49b5735843af2348733797.png" src="../../_images/6bbf902247bd6146c58ff00c41c0f66ce9e48e3d8a49b5735843af2348733797.png" />
</div>
</div>
<p>Next, let’s look at an example where the emoji does not make use of all available space.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load &#39;ice&#39; emoji</span>
<span class="n">ice_np</span> <span class="o">=</span> <span class="n">load_emoji</span><span class="p">(</span><span class="s1">&#39;classic-dobble&#39;</span><span class="p">,</span> <span class="s1">&#39;ice&#39;</span><span class="p">)</span>

<span class="n">ice_pil</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">ice_np</span><span class="p">)</span>
<span class="n">ice_rescaled_pil</span> <span class="o">=</span> <span class="n">rescale_emoji</span><span class="p">(</span><span class="n">ice_np</span><span class="p">)</span>
<span class="n">images</span> <span class="o">=</span> <span class="p">[</span><span class="n">ice_pil</span><span class="p">,</span> <span class="n">ice_rescaled_pil</span><span class="p">]</span>

<span class="c1"># Prepare subplot</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;reports/figures/emojis/enlarged-emoji.png&#39;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>

    <span class="n">image_size</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">draw</span> <span class="o">=</span> <span class="n">ImageDraw</span><span class="o">.</span><span class="n">Draw</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="n">draw</span><span class="o">.</span><span class="n">ellipse</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_size</span><span class="p">,</span> <span class="n">image_size</span><span class="p">),</span> <span class="n">outline</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Original&#39;</span> <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;Rescaled&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Enlargening Emojis&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">file_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/4387265650d47bc07131da8c9cd89b29ce57ea8af9585d369e32099cab7c0130.png" src="../../_images/4387265650d47bc07131da8c9cd89b29ce57ea8af9585d369e32099cab7c0130.png" />
</div>
</div>
<p>Finally, let’s load and resize all the emojis in the <code class="docutils literal notranslate"><span class="pre">classic-dobble</span></code> set.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;reports/figures/emojis/resized-classic-dobble-emojis.png&#39;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">classic_dobble_emoji_names</span><span class="p">):</span>  <span class="c1"># Check if there are still emojis remaining</span>
        <span class="c1"># Load and resize emoji image</span>
        <span class="n">emoji_image_pil</span> <span class="o">=</span> <span class="n">rescale_emoji</span><span class="p">(</span><span class="n">load_emoji</span><span class="p">(</span><span class="s1">&#39;classic-dobble&#39;</span><span class="p">,</span> <span class="n">classic_dobble_emoji_names</span><span class="p">[</span><span class="n">count</span><span class="p">]))</span>

        <span class="c1"># Draw inscribed circle</span>
        <span class="n">image_size</span> <span class="o">=</span> <span class="n">emoji_image_pil</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">draw</span> <span class="o">=</span> <span class="n">ImageDraw</span><span class="o">.</span><span class="n">Draw</span><span class="p">(</span><span class="n">emoji_image_pil</span><span class="p">)</span>
        <span class="n">draw</span><span class="o">.</span><span class="n">ellipse</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_size</span><span class="p">,</span> <span class="n">image_size</span><span class="p">),</span> <span class="n">outline</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

        <span class="c1"># Show image</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">emoji_image_pil</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Resized Emojis in the Classic Dobble Deck&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">file_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/4a80424d3fba779c9ea908a55bf1a7aaa7c787cd56e737fdd4026091710b57db.png" src="../../_images/4a80424d3fba779c9ea908a55bf1a7aaa7c787cd56e737fdd4026091710b57db.png" />
</div>
</div>
<p>By now, we know which emojis exist in which set, we can load any of these emojis into memory, and we can manipulate their size appropriately. Next, we need a function that <strong>pastes an individual emoji</strong> onto another image (which will be our playing card, of course).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">place_emoji</span><span class="p">(</span>
        <span class="n">image</span><span class="p">:</span> <span class="n">Image</span><span class="o">.</span><span class="n">Image</span><span class="p">,</span>
        <span class="n">emoji_image</span><span class="p">:</span> <span class="n">Image</span><span class="o">.</span><span class="n">Image</span><span class="p">,</span>
        <span class="n">emoji_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">emoji_center</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">rotation_angle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_pil</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Image</span><span class="o">.</span><span class="n">Image</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Place an emoji on the given image at the specified coordinates with the specified size.</span>

<span class="sd">    Args:</span>
<span class="sd">        image (Image.Image): The image on which the emoji is to be placed.</span>
<span class="sd">        emoji_image (Image.Image): The emoji image to be placed on the image.</span>
<span class="sd">        emoji_size (int): The desired size of the emoji in pixels when placed on the image.</span>
<span class="sd">        emoji_center (tuple[int, int]): The coordinates of the center of the emoji in the form (x, y).</span>
<span class="sd">        rotation_angle (float): The angle (in degrees) by which to rotate the emoji.  Defaults to None.</span>
<span class="sd">        return_pil (bool): Whether to return a PIL Image (True) or a NumPy array (False).  Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Image.Image or np.ndarray: The image with the emoji placed on it.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the &#39;rotation_angle&#39; is provided but is outside the valid range [0, 360).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_center</span><span class="p">,</span> <span class="n">y_center</span> <span class="o">=</span> <span class="n">emoji_center</span>

    <span class="c1"># Calculate the top-left coordinates of the emoji based on the center coordinates and size</span>
    <span class="n">x_left</span> <span class="o">=</span> <span class="n">x_center</span> <span class="o">-</span> <span class="n">emoji_size</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">y_top</span> <span class="o">=</span> <span class="n">y_center</span> <span class="o">-</span> <span class="n">emoji_size</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="c1"># Resize the emoji to the specified size</span>
    <span class="n">emoji_image</span> <span class="o">=</span> <span class="n">emoji_image</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="n">emoji_size</span><span class="p">,</span> <span class="n">emoji_size</span><span class="p">))</span>

    <span class="c1"># Rotate the emoji if a rotation angle is provided</span>
    <span class="k">if</span> <span class="n">rotation_angle</span><span class="p">:</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">rotation_angle</span> <span class="o">&lt;</span> <span class="mi">360</span><span class="p">:</span>
            <span class="n">emoji_image</span> <span class="o">=</span> <span class="n">emoji_image</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">rotation_angle</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid rotation angle: must be in the range [0, 360).&#39;</span><span class="p">)</span>

    <span class="c1"># Paste the emoji onto the original image at the specified coordinates</span>
    <span class="n">image</span><span class="o">.</span><span class="n">paste</span><span class="p">(</span><span class="n">emoji_image</span><span class="p">,</span> <span class="p">(</span><span class="n">x_left</span><span class="p">,</span> <span class="n">y_top</span><span class="p">),</span> <span class="n">mask</span><span class="o">=</span><span class="n">emoji_image</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">image</span> <span class="k">if</span> <span class="n">return_pil</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s take the <code class="docutils literal notranslate"><span class="pre">four-leaf-clover</span></code> emoji, resize it, rotate it by 15 degrees clockwise, and place it onto the empty playing card we created earlier.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">empty_playing_card</span> <span class="o">=</span> <span class="n">create_empty_card</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
<span class="n">clover_image</span> <span class="o">=</span> <span class="n">rescale_emoji</span><span class="p">(</span><span class="n">load_emoji</span><span class="p">(</span><span class="s1">&#39;classic-dobble&#39;</span><span class="p">,</span> <span class="s1">&#39;four-leaf-clover&#39;</span><span class="p">))</span>
<span class="n">emoji_size</span> <span class="o">=</span> <span class="mi">512</span>
<span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">)</span>
<span class="n">rotation_angle</span> <span class="o">=</span> <span class="mi">345</span>  <span class="c1"># 15 degrees clockwise correspond to 345 degrees counterclockwise</span>
<span class="n">playing_card_with_single_emoji</span> <span class="o">=</span> <span class="n">place_emoji</span><span class="p">(</span>
    <span class="n">empty_playing_card</span><span class="p">,</span> <span class="n">clover_image</span><span class="p">,</span> <span class="n">emoji_size</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">rotation_angle</span><span class="p">,</span> <span class="n">return_pil</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
<span class="n">playing_card_with_single_emoji</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>

<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">playing_card_with_single_emoji</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;A Playing Card With a Single Emoji&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/aaee43ccd3b231b70d36a4ff5ddcaadc400c003a28739bff1bd74bcafa4c2e7f.png" src="../../_images/aaee43ccd3b231b70d36a4ff5ddcaadc400c003a28739bff1bd74bcafa4c2e7f.png" />
</div>
</div>
<p>Now that the fun part is done, we need to find a <strong>systematic way of placing multiple emojis</strong> onto a single playing card. When doing so, we want to …</p>
<ul class="simple">
<li><p>utilize the available space of each playing card as much as possible,</p></li>
<li><p>make sure that no two emojis overlap.</p></li>
</ul>
<p>To accomplish this, we rely on results from a mathematical branch called <em>circle packing</em>.</p>
</section>
<section id="circle-packing">
<h3>Circle Packing<a class="headerlink" href="#circle-packing" title="Link to this heading">#</a></h3>
<p>Why do we need to deal with the theory of <em>circle packing</em>? Well, here is an extract of the <a class="reference external" href="https://en.wikipedia.org/wiki/Circle_packing">Wikipedia article</a> on the theory of circle packing:</p>
<blockquote>
<div><p><em>In geometry, circle packing is the study of the arrangement of circles (of equal or varying sizes) on a given surface such that <strong>no overlapping</strong> occurs and so that <strong>no circle can be enlarged without creating an overlap</strong>.</em></p>
</div></blockquote>
<p>Sounds familiar? Loosely speaking, packings satisfying the two conditions highlighted in <strong>bold</strong> are called <em>optimal</em>. So, here’s the general approach we will take: For a given number <span class="math notranslate nohighlight">\(n\)</span> of emojis that we want to place on a playing card, we choose an optimal circle packing consisting of <span class="math notranslate nohighlight">\(n\)</span> circles and we center each emoji on the center of one of the circles. The size of the emoji will be determined by the size of the corresponding circle (i.e., its diameter). This works out quite well since …</p>
<ul class="simple">
<li><p>the emojis provided by <a class="reference external" href="https://openmoji.org">OpenMoji</a> are square images (618 x 618 pixels) with a transparent background,</p></li>
<li><p>most emojis do not extend much into the corners of the image due to the <a class="reference external" href="https://openmoji.org/styleguide/#styleguide">styleguide</a> that’s used by <a class="reference external" href="https://openmoji.org">OpenMoji</a>.</p></li>
</ul>
<p>For thus emojis that do extend into the corners of the image, our <code class="docutils literal notranslate"><span class="pre">rescale_emoji</span></code> function will scale down the emoji so that it does not overlap with any other emoji on the playing card. Thus, all we need are optimal packings for different numbers of circles. That way we can create <em>Dobble</em> decks with varying numbers of symbols per card. Ideally, we also have multiple (optimal) packings for a fixed number of circles. This would allow us to have different layouts across playing cards of a single deck. Luckily, Prof. Dr.-Ing. <a class="reference external" href="https://www.ltv.ovgu.de/Mitarbeiter/Lehrstuhlinhaber/Prof_+Eckehard+Specht-p-210.html">Eckehard Specht</a> provides an incredible amount of data on optimal packings on his website <a class="reference external" href="http://www.packomania.com">packomania.com</a>. From this website, we have downloaded the data that we need and placed it into the following directory (relative to this notebook): <code class="docutils literal notranslate"><span class="pre">data/external/packings/</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">PACKINGS_DIR</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;data/external/packings&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Inside this directory, there are the following five subdirectories:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cci</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ccib</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ccic</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ccir</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ccis</span></code></p></li>
</ul>
<p>The names of these subdirectories are simply the names that Prof. Dr.-Ing. Eckehard Specht uses for the different types of packings that he provides on his website (e.g., the data in the <code class="docutils literal notranslate"><span class="pre">cci</span></code> directory was taken from <a class="reference external" href="http://hydra.nat.uni-magdeburg.de/packing/cci/cci.html">http://hydra.nat.uni-magdeburg.de/packing/<strong>cci</strong>/<strong>cci</strong>.html</a>). All of these subdirectories qualitatively contain the same data:</p>
<ul class="simple">
<li><p>Multiple text files containing the <strong>coordinates of each circle</strong> in the packing. The file names consist of the name of the directory followed by the number of circles in the circle packing (e.g., <code class="docutils literal notranslate"><span class="pre">cci4.txt</span></code> or <code class="docutils literal notranslate"><span class="pre">ccir32.txt</span></code>). All text files consist of three columns: the first column stores a simple counter, the second column contains the <span class="math notranslate nohighlight">\(x\)</span>-coordinate, and the third column contains the <span class="math notranslate nohighlight">\(y\)</span>-coordinate of the center of each circle. The coordinates of these circle centers have to be interpreted in relation to the large circle that contains all of the smaller circles. This large circle is centered at <span class="math notranslate nohighlight">\((0, 0)\)</span> and has a radius of <span class="math notranslate nohighlight">\(1\)</span>, i.e., it is defined by the equation <span class="math notranslate nohighlight">\(x^2 + y^2 = 1\)</span>.</p></li>
<li><p>A single text file <code class="docutils literal notranslate"><span class="pre">radius.txt</span></code> that stores the <strong>radius of the largest circle</strong> of each circle packing. This file contains two columns: the first one specifies the number of circles in the circle packing and the second one provides the radius of the largest circle in the packing. The radii of all the other circles can be computed based on this radius. We will get back to this later. As was the case for the coordinate values, these radii have to be interpreted in relation to the radius of the large circle containing all of the smaller circles.</p></li>
</ul>
<p>Generally, this data is available for circle packings where the number of circles are integers up to <span class="math notranslate nohighlight">\(n = 50\)</span> that can be expressed as <span class="math notranslate nohighlight">\(p^k + 1\)</span> with <span class="math notranslate nohighlight">\(p\)</span> being prime (i.e., integers that immediately follow a prime power).</p>
<p><strong>Important</strong>: For <span class="math notranslate nohighlight">\(n = 3, 4\)</span> this data is <strong>only</strong> available for circle packings of type <code class="docutils literal notranslate"><span class="pre">cci</span></code>.</p>
<p>Next, let’s define a dictionary <code class="docutils literal notranslate"><span class="pre">PACKING_TYPES_DICT</span></code> that stores all the different types of packings that are available in our directory <code class="docutils literal notranslate"><span class="pre">data/external/packings/</span></code>. The value associated with each key is a tuple consisting of …</p>
<ul class="simple">
<li><p>a function that can be used to compute the remaining radii of a circle packing of that type,</p></li>
<li><p>a string that indicates whether this function is monotonically increasing or decreasing.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">PACKING_TYPES_DICT</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;cci&#39;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;increasing&#39;</span><span class="p">),</span>
    <span class="s1">&#39;ccir&#39;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;increasing&#39;</span><span class="p">),</span>
    <span class="s1">&#39;ccis&#39;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;decreasing&#39;</span><span class="p">),</span>
    <span class="s1">&#39;ccib&#39;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">),</span> <span class="s1">&#39;decreasing&#39;</span><span class="p">),</span>
    <span class="s1">&#39;ccic&#39;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;decreasing&#39;</span><span class="p">)</span>
    <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>We now have all the raw data that we need for our project. What’s needed now, is a <strong>set of functions that allows us to conveniently access this data</strong>. Essentially, we want to be able to specify</p>
<ul class="simple">
<li><p>the type of packing that we want to use (i.e., one of the keys in the <code class="docutils literal notranslate"><span class="pre">PACKING_TYPES_DICT</span></code>),</p></li>
<li><p>the number of emojis that we want to place on a playing card,</p></li>
<li><p>the size of the playing card in pixels (i.e., the size of the square image of a white disk against a transparent background),</p></li>
</ul>
<p>and we want to get back the coordinates (in pixels) of where to place each emoji as well as each emoji’s size (in pixels). We could then use this information to iteratively place single emojis on our playing cards using the <code class="docutils literal notranslate"><span class="pre">place_emoji</span></code> function. Let’s break the process of reading in and preprocessing the packing data down into three simple steps:</p>
<ol class="arabic simple">
<li><p>Read in the raw data (i.e., coordinates of all circles and radius of the largest circle) for a given packing</p></li>
<li><p>Based on the radius of the largest circle and the type of packing, compute the radii of all remaining circles in the packing</p></li>
<li><p>Convert the data into pixel values based on the size of the playing card that ought to be generated</p></li>
</ol>
<p>Let’s start with the first step of <strong>reading in the raw data</strong>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">read_coordinates_from_file</span><span class="p">(</span>
        <span class="n">num_circles</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">packing_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read the coordinates of the specified circle packing from a text file.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_circles (int): Number of circles in the packing.</span>
<span class="sd">        packing_type (str): Type of circle packing.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list[list[float]]: The coordinates of the circles in the packing.</span>

<span class="sd">    Raises:</span>
<span class="sd">        FileNotFoundError: If the text file for the specified packing type and number of circles is not found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">file_name</span> <span class="o">=</span> <span class="n">PACKINGS_DIR</span> <span class="o">/</span> <span class="n">packing_type</span> <span class="o">/</span> <span class="p">(</span><span class="n">packing_type</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_circles</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.txt&#39;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="c1"># Read values line by line, split into separate columns and get rid of first column of text file</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="o">.</span><span class="n">readlines</span><span class="p">()]</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">float</span><span class="p">(</span><span class="n">coordinate</span><span class="p">)</span> <span class="k">for</span> <span class="n">coordinate</span> <span class="ow">in</span> <span class="n">coordinates_list</span><span class="p">]</span> <span class="k">for</span> <span class="n">coordinates_list</span> <span class="ow">in</span> <span class="n">coordinates</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">coordinates</span>
    <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Coordinates file for &#39;</span><span class="si">{</span><span class="n">packing_type</span><span class="si">}</span><span class="s2">&#39; packing with </span><span class="si">{</span><span class="n">num_circles</span><span class="si">}</span><span class="s2"> circles not found.&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">read_radius_from_file</span><span class="p">(</span>
        <span class="n">num_circles</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">packing_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read the radius of the largest circle of the specified circle packing from a text file.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_circles (int): Number of circles in the packing.</span>
<span class="sd">        packing_type (str): Type of circle packing.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The radius of the largest circle of the packing.</span>

<span class="sd">    Raises:</span>
<span class="sd">        FileNotFoundError: If the text file for the specified packing type is not found.</span>
<span class="sd">        ValueError: If no radius is found for the specified packing type and number of circles.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">file_name</span> <span class="o">=</span> <span class="n">PACKINGS_DIR</span> <span class="o">/</span> <span class="n">packing_type</span> <span class="o">/</span> <span class="s1">&#39;radius.txt&#39;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">num_circles</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No radius found for packing type &#39;</span><span class="si">{</span><span class="n">packing_type</span><span class="si">}</span><span class="s2">&#39; with </span><span class="si">{</span><span class="n">num_circles</span><span class="si">}</span><span class="s2"> circles.&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Radius file for &#39;</span><span class="si">{</span><span class="n">packing_type</span><span class="si">}</span><span class="s2">&#39; packing not found.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>As mentioned before, the <code class="docutils literal notranslate"><span class="pre">radius.txt</span></code> file in each subdirectory contains only the radius of the largest circle in each packing. The radii of the remaining circle can be computed as follows: Each type of packing is described by the radii of the circle it’s made up of. For example, the radii (relative to the radius of the largest circle in the packing) of the packings of type <code class="docutils literal notranslate"><span class="pre">ccir</span></code> are described by the function <span class="math notranslate nohighlight">\(r_i = \sqrt{i}\)</span>. Let’s look at a concrete example: Assume that we want to compute the radii of all of the circles in a packing of type <code class="docutils literal notranslate"><span class="pre">ccir</span></code> with <span class="math notranslate nohighlight">\(5\)</span> circles. The function <span class="math notranslate nohighlight">\(r_i\)</span> then yields the following values:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(r_1 = \sqrt{1} = 1\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(r_2 = \sqrt{2} \approx 1.4142\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(r_3 = \sqrt{3} \approx 1.7321\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(r_4 = \sqrt{4} = 2\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(r_5 = \sqrt{5} \approx 2.2361\)</span></p></li>
</ul>
<p>As we can see right away, these are not the final radii (remember that the large circle that contains all the smaller circles only has a radius of 1!). Instead, these values simply describe the ratios of the circles in a packing <em>relative to each other</em>. To obtain the absolute radii, we first take the radius of the largest circle in the packing (which we obtain from the <code class="docutils literal notranslate"><span class="pre">radius.txt</span></code> file) and divide it by the largest value of the sequence of values <span class="math notranslate nohighlight">\(r_1, \dots, r_5\)</span>. In this particular case, this gives us <span class="math notranslate nohighlight">\(0.49454334 / 2.2361 \approx 0.2212\)</span>. All we need to do now is multiply the sequence of values <span class="math notranslate nohighlight">\(r_1, \dots, r_5\)</span> by this constant factor to obtain the final radii:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(r_1 \times 0.2212 \approx 0.2212\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(r_2 \times 0.2212 \approx 0.3128\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(r_3 \times 0.2212 \approx 0.3831\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(r_4 \times 0.2212 \approx 0.4423\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(r_5 \times 0.2212 \approx 0.4945\)</span></p></li>
</ul>
<p>These are the actual radii that we were looking for. Note that the final value in the list above coincides with the radius supplied in the <code class="docutils literal notranslate"><span class="pre">radius.txt</span></code> file. This is no coincidence because this value was computed as
$<span class="math notranslate nohighlight">\(
r_5 \times 0.2212 = r_5 \times \frac{0.4945}{r_5} = 0.4945 \, .
\)</span>$</p>
<p>Let’s turn all of this into a function!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compute_radii</span><span class="p">(</span>
        <span class="n">num_circles</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">packing_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">largest_radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the radii of circles in a circle packing.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_circles (int): Total number of circles in the packing.</span>
<span class="sd">        packing_type (str): Type of circle packing.</span>
<span class="sd">        largest_radius (float): Radius of the largest circle in the packing.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list[float]: The computed radii of the circles in the packing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">radius_function</span><span class="p">,</span> <span class="n">monotonicity</span> <span class="o">=</span> <span class="n">PACKING_TYPES_DICT</span><span class="p">[</span><span class="n">packing_type</span><span class="p">]</span>
    <span class="n">function_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">radius_function</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_circles</span><span class="p">)]</span>

    <span class="c1"># If the function &#39;radius_function&#39; is decreasing, we reverse the order</span>
    <span class="c1"># of &#39;function_values&#39; so that the values are listed in increasing order</span>
    <span class="n">function_values</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span> <span class="k">if</span> <span class="n">monotonicity</span> <span class="o">==</span> <span class="s1">&#39;decreasing&#39;</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="n">ratio</span> <span class="o">=</span> <span class="n">largest_radius</span> <span class="o">/</span> <span class="n">function_values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">radii</span> <span class="o">=</span> <span class="p">[</span><span class="n">function_values</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">ratio</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_circles</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">radii</span>
</pre></div>
</div>
</div>
</div>
<p>Now that we have both, the circle centers as well as the radii, we need to convert these values into pixel values based on the size of the square image that will serve as our playing card. This is easy.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">convert_coordinates_to_pixels</span><span class="p">(</span>
        <span class="n">rel_coordinates</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">image_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert relative coordinates to pixel values based on the size of a square image.</span>

<span class="sd">    The function takes relative coordinates in the range of [-1, 1] and converts them to pixel values</span>
<span class="sd">    based on the size of a square image.  The relative coordinates are assumed to be in normalized form,</span>
<span class="sd">    where the origin (0, 0) corresponds to the center of the image and the values (-1, -1) and (1, 1)</span>
<span class="sd">    correspond to the lower left and upper right corner of the image, respectively.</span>

<span class="sd">    Args:</span>
<span class="sd">        rel_coordinates (np.ndarray[float, float] | tuple[float, float]): Relative coordinates in the range of [-1, 1].</span>
<span class="sd">        image_size (int): Size of the square image that coordinates are to be based on.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[int, int]: Pixel values corresponding to the relative coordinates.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the relative coordinates are outside the range of [-1, 1].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert rel_coordinates to NumPy array if necessary</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rel_coordinates</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">rel_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rel_coordinates</span><span class="p">)</span>

    <span class="c1"># Check if the relative coordinates are within the range of [-1, 1]</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">rel_coordinates</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">rel_coordinates</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Relative coordinates must be in the range of [-1, 1].&#39;</span><span class="p">)</span>

    <span class="c1"># Shift coordinates from [-1, 1] to [0, 1]</span>
    <span class="n">rel_coordinates</span> <span class="o">=</span> <span class="n">rel_coordinates</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span>

    <span class="c1"># Scale coordinates from [0, 1] to [0, card_size] and convert to integer values</span>
    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">rel_coordinates</span> <span class="o">*</span> <span class="n">image_size</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">convert_radius_to_pixels</span><span class="p">(</span>
        <span class="n">rel_radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">image_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert relative radius to pixel value based on the size of a square image.</span>

<span class="sd">    Args:</span>
<span class="sd">        rel_radius (float): Relative radius in the range of [0, 1].</span>
<span class="sd">        image_size (int): Size of the square image that radii are to be based on.</span>

<span class="sd">    Returns:</span>
<span class="sd">        int: Pixel value corresponding to the relative radius.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the relative radius is outside the valid range of [0, 1].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rel_radius</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">rel_radius</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Relative radius must be in the range of [0, 1].&#39;</span><span class="p">)</span>

    <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rel_radius</span> <span class="o">*</span> <span class="n">image_size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">size</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, let’s <strong>combine</strong> all these individual steps <strong>into one, easy-to-use function</strong>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_packing_data</span><span class="p">(</span>
        <span class="n">num_circles</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">packing_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">image_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        num_circles (int): Total number of circles in the packing.</span>
<span class="sd">        packing_type (str): Type of circle packing.</span>
<span class="sd">        image_size (int): Size of the square image that coordinates and radii are to be based on.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict[str, list]: A dictionary containing the coordinates and sizes in pixel values.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the packing type is not one of the supported packing types.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">packing_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">PACKING_TYPES_DICT</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid packing type: &#39;</span><span class="si">{</span><span class="n">packing_type</span><span class="si">}</span><span class="s2">&#39; is not supported.&quot;</span><span class="p">)</span>

    <span class="c1"># Coordinates</span>
    <span class="n">rel_coordinates_array</span> <span class="o">=</span> <span class="n">read_coordinates_from_file</span><span class="p">(</span><span class="n">num_circles</span><span class="p">,</span> <span class="n">packing_type</span><span class="p">)</span>
    <span class="n">coordinates</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">convert_coordinates_to_pixels</span><span class="p">(</span><span class="n">rel_coordinates</span><span class="p">,</span> <span class="n">image_size</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">rel_coordinates</span> <span class="ow">in</span> <span class="n">rel_coordinates_array</span>
        <span class="p">]</span>

    <span class="c1"># Sizes</span>
    <span class="n">largest_radius</span> <span class="o">=</span> <span class="n">read_radius_from_file</span><span class="p">(</span><span class="n">num_circles</span><span class="p">,</span> <span class="n">packing_type</span><span class="p">)</span>
    <span class="n">rel_radii</span> <span class="o">=</span> <span class="n">compute_radii</span><span class="p">(</span><span class="n">num_circles</span><span class="p">,</span> <span class="n">packing_type</span><span class="p">,</span> <span class="n">largest_radius</span><span class="p">)</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert_radius_to_pixels</span><span class="p">(</span><span class="n">rel_radius</span><span class="p">,</span> <span class="n">image_size</span><span class="p">)</span> <span class="k">for</span> <span class="n">rel_radius</span> <span class="ow">in</span> <span class="n">rel_radii</span><span class="p">]</span>

    <span class="c1"># Combine into dictionary</span>
    <span class="n">packing_data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;coordinates&#39;</span><span class="p">:</span> <span class="n">coordinates</span><span class="p">,</span>
        <span class="s1">&#39;sizes&#39;</span><span class="p">:</span> <span class="n">sizes</span>
        <span class="p">}</span>

    <span class="k">return</span> <span class="n">packing_data</span>
</pre></div>
</div>
</div>
</div>
<p>To make sure that everything is working as expected, let us <strong>visualize a few circle packings</strong>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">num_circles_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="n">image_size</span> <span class="o">=</span> <span class="mi">1024</span>

<span class="c1"># Visualize different numbers of circles across rows and different packing types across columns</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;reports/figures/packings/packings-illustration.png&#39;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">num_circles</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">num_circles_list</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">packing_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">PACKING_TYPES_DICT</span><span class="p">):</span>
        <span class="c1"># Obtain packing data</span>
        <span class="n">packing_data</span> <span class="o">=</span> <span class="n">get_packing_data</span><span class="p">(</span><span class="n">num_circles</span><span class="p">,</span> <span class="n">packing_type</span><span class="p">,</span> <span class="n">image_size</span><span class="p">)</span>
        
        <span class="c1"># Create emtpy card</span>
        <span class="n">packing</span> <span class="o">=</span> <span class="n">create_empty_card</span><span class="p">(</span><span class="n">image_size</span><span class="p">)</span>

        <span class="c1"># Iteratively draw circles on card</span>
        <span class="k">for</span> <span class="n">circle</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_circles</span><span class="p">):</span>
            <span class="n">center_x</span><span class="p">,</span> <span class="n">center_y</span> <span class="o">=</span> <span class="n">packing_data</span><span class="p">[</span><span class="s1">&#39;coordinates&#39;</span><span class="p">][</span><span class="n">circle</span><span class="p">]</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="n">packing_data</span><span class="p">[</span><span class="s1">&#39;sizes&#39;</span><span class="p">][</span><span class="n">circle</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>

            <span class="n">draw</span> <span class="o">=</span> <span class="n">ImageDraw</span><span class="o">.</span><span class="n">Draw</span><span class="p">(</span><span class="n">packing</span><span class="p">)</span>
            <span class="n">draw</span><span class="o">.</span><span class="n">ellipse</span><span class="p">(</span>
                <span class="p">(</span><span class="n">center_x</span> <span class="o">-</span> <span class="n">radius</span><span class="p">,</span> <span class="n">center_y</span> <span class="o">-</span> <span class="n">radius</span><span class="p">,</span>
                 <span class="n">center_x</span> <span class="o">+</span> <span class="n">radius</span><span class="p">,</span> <span class="n">center_y</span> <span class="o">+</span> <span class="n">radius</span>
                <span class="p">),</span> <span class="n">fill</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Convert to NumPy array</span>
        <span class="n">packing_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">packing</span><span class="p">)</span>

        <span class="c1"># Make the image fully opaque (i.e., turn transparent background black)</span>
        <span class="n">packing_np</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>

        <span class="c1"># Separate color channels and alpha channel</span>
        <span class="n">color_channels</span> <span class="o">=</span> <span class="n">packing_np</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">alpha_channel</span> <span class="o">=</span> <span class="n">packing_np</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

        <span class="c1"># Invert color channels</span>
        <span class="n">inverted_color_channels</span> <span class="o">=</span> <span class="mi">255</span> <span class="o">-</span> <span class="n">color_channels</span>

        <span class="c1"># Combine inverted color channels with alpha channel</span>
        <span class="n">packing_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span><span class="n">inverted_color_channels</span><span class="p">,</span> <span class="n">alpha_channel</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span>
        
        <span class="n">axes</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">packing_np</span><span class="p">)</span>
        <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">packing_type</span><span class="si">}</span><span class="s1">, n=</span><span class="si">{</span><span class="n">num_circles</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Circle Packings&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">file_path</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">file_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/20d709965069cc1beee5a19dd8f9b676891b7afa865bcacf9db7d971a1c4f53b.png" src="../../_images/20d709965069cc1beee5a19dd8f9b676891b7afa865bcacf9db7d971a1c4f53b.png" />
</div>
</div>
</section>
<section id="finite-projective-planes">
<h3>Finite Projective Planes<a class="headerlink" href="#finite-projective-planes" title="Link to this heading">#</a></h3>
<p>In the first chapter of this notebook, we have already established that a deck of <em>Dobble</em> playing cards corresponds to a finite projective plane, where the order of the latter is one less than the number of symbols on each card. Thus, to create a valid <em>Dobble</em> deck (i.e., a set of playing cards such that each pair of cards shares exactly one symbol), we need to compute the so-called <em>incidence matrix</em> of its corresponding projective plane. This incidence matrix tells us which points belong to which line (or in <em>Dobble</em> terms: which symbol should go on which card).</p>
<p>Since the construction we want to use (called the <em>vector space construction with finite fields</em>) to construct finite projective planes only works for orders <span class="math notranslate nohighlight">\(n = p^k\)</span> that are prime powers, let’s quickly implement <strong>two functions</strong> that we can use to <strong>check whether a given integer is a prime power or not</strong>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">num</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if a number is prime.</span>

<span class="sd">    Args:</span>
<span class="sd">        num (float): The number to be checked.</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: True if the number is prime, False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_integer</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="n">num</span><span class="o">.</span><span class="n">is_integer</span><span class="p">())</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_integer</span> <span class="ow">or</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Check for non-trivial factors</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">num</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">is_prime_power</span><span class="p">(</span><span class="n">num</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if a number is a prime power.</span>

<span class="sd">    Args:</span>
<span class="sd">        num (float): The number to be checked.</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: True if the number is a prime power, False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_integer</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="n">num</span><span class="o">.</span><span class="n">is_integer</span><span class="p">())</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_integer</span> <span class="ow">or</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Compute the i-th root of num and check if it&#39;s prime</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">num</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">num</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span> <span class="ow">and</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
</div>
</div>
<p>Now that we have this, let’s implement an algorithm that constructs the incidence matrix for a finite projective plane of order <span class="math notranslate nohighlight">\(n = p^k\)</span>, with <span class="math notranslate nohighlight">\(p\)</span> being a prime number.</p>
<p><strong>Note</strong>: The function <code class="docutils literal notranslate"><span class="pre">compute_incidence_matrix</span></code> is based on the algorithm by <a class="reference external" href="https://purl.pt/2228/1/j-5293-b-vol12-fasc3-art3_PDF/j-5293-b-vol12-fasc3-art3_PDF_01-B-R0300/j-5293-b-vol12-fasc3-art3_0000_capa1-112_t01-B-R0300.pdf">Paige and Wexler (1953)</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_permutation_matrix</span><span class="p">(</span><span class="n">permutation</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the permutation matrix corresponding to the permutation.</span>

<span class="sd">    Args:</span>
<span class="sd">        permutation (np.ndarray): The permutation to be converted to a</span>
<span class="sd">            permutation matrix.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: The permutation matrix corresponding to the</span>
<span class="sd">            permutation.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the passed argument is not a valid permutation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if the permutation is valid</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">permutation</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">permutation</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span>
            <span class="ow">or</span> <span class="nb">set</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid permutation.&quot;</span><span class="p">)</span>

    <span class="c1"># Construct permutation matrix</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span>
    <span class="n">permutation_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="n">permutation_matrix</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">permutation</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">permutation_matrix</span>


<span class="k">def</span> <span class="nf">compute_incidence_matrix</span><span class="p">(</span><span class="n">order</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the canonical incidence matrix of a finite projective</span>
<span class="sd">       plane with prime order based on the construction by</span>
<span class="sd">       Paige and Wexler (1953).</span>

<span class="sd">    Args:</span>
<span class="sd">        order (int): The order of the finite projective plane.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: The computed incidence matrix.  Rows correspond to</span>
<span class="sd">            lines and columns correspond to points.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the argument order is not a prime number.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; compute_incidence_matrix(2)</span>
<span class="sd">        array([[1, 1, 1, 0, 0, 0, 0],</span>
<span class="sd">               [1, 0, 0, 1, 1, 0, 0],</span>
<span class="sd">               [1, 0, 0, 0, 0, 1, 1],</span>
<span class="sd">               [0, 1, 0, 1, 0, 1, 0],</span>
<span class="sd">               [0, 1, 0, 0, 1, 0, 1],</span>
<span class="sd">               [0, 0, 1, 1, 0, 0, 1],</span>
<span class="sd">               [0, 0, 1, 0, 1, 1, 0]], dtype=uint8)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The argument &#39;order&#39; must be a prime.&quot;</span><span class="p">)</span>

    <span class="c1"># Number of points/lines of an FPP of order n</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">order</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Set up incidence matrix</span>
    <span class="c1">#   - rows correspond to lines</span>
    <span class="c1">#   - columns correspond to points</span>
    <span class="n">incidence_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

    <span class="c1"># a) P_1, P_2, ..., P_{n+1} are the points of L_1</span>
    <span class="n">incidence_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># b) L_1, L_2, ..., L_{n+1} are the lines through P_1</span>
    <span class="n">incidence_matrix</span><span class="p">[:</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">order</span>

        <span class="c1"># c) P_{kn+2}, P_{kn+3}, ..., P_{kn+n+1} lie on L_{k+1}, k = 1, 2, ..., n</span>
        <span class="n">incidence_matrix</span><span class="p">[</span><span class="n">block</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># d) L_{kn+2}, L_{kn+3}, ..., L_{kn+n+1} lie on P_{k+1}, k = 1, 2, ..., n</span>
        <span class="n">incidence_matrix</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">,</span> <span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">stop</span>

    <span class="c1"># Kernel of the incidence matrix (i.e., n^2 permutation matrices C_{ij})</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="c1"># Determine permutation matrix C_{ij}</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">permutation_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">leading_entry</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">j</span><span class="p">)</span> <span class="o">%</span> <span class="n">order</span>
            <span class="k">if</span> <span class="n">leading_entry</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">leading_entry</span> <span class="o">=</span> <span class="n">order</span>
            <span class="n">permutation</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">order</span><span class="p">))</span> <span class="o">+</span> <span class="n">leading_entry</span><span class="p">)</span> <span class="o">%</span> <span class="n">order</span>
            <span class="n">permutation</span><span class="p">[</span><span class="n">permutation</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">order</span>
            <span class="n">permutation_matrix</span> <span class="o">=</span> <span class="n">get_permutation_matrix</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span>

        <span class="c1"># Place permutation matrix C_{ij} in incidence matrix</span>
        <span class="n">start_row</span> <span class="o">=</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">order</span>
        <span class="n">start_col</span> <span class="o">=</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">order</span>
        <span class="n">end_row</span> <span class="o">=</span> <span class="n">start_row</span> <span class="o">+</span> <span class="n">order</span>
        <span class="n">end_col</span> <span class="o">=</span> <span class="n">start_col</span> <span class="o">+</span> <span class="n">order</span>
        <span class="n">incidence_matrix</span><span class="p">[</span><span class="n">start_row</span><span class="p">:</span><span class="n">end_row</span><span class="p">,</span> <span class="n">start_col</span><span class="p">:</span><span class="n">end_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">permutation_matrix</span>

    <span class="k">return</span> <span class="n">incidence_matrix</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="dobble-decks">
<h3>Dobble Decks<a class="headerlink" href="#dobble-decks" title="Link to this heading">#</a></h3>
<p>We now have everything that we need to create our own custom <em>Dobble</em> decks. Here, we throw everything together into a single function that creates a full set of playing cards. Before we do so, let’s quickly implement a function that <strong>generates a single playing card</strong>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_dobble_card</span><span class="p">(</span>
        <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">image_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">packing_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">emoji_set</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">emoji_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">outline_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_pil</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Image</span><span class="o">.</span><span class="n">Image</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a single Dobble playing card.</span>

<span class="sd">    Args:</span>
<span class="sd">        scale (float): Determines to what extent the emoji should fill the inscribed circle.</span>
<span class="sd">        image_size (int): The size of the square image in pixels.</span>
<span class="sd">        packing_type (str): The type of circle packing.</span>
<span class="sd">        emoji_set (str): The name of the set of emojis (e.g., &#39;classic-dobble&#39;)</span>
<span class="sd">        emoji_list (list[str]): The list of names of the emojis to be placed on the playing card.</span>
<span class="sd">        outline_only (bool): Whether to load the outline-only version of the emoji.  Defaults to False.</span>
<span class="sd">        return_pil (bool): Whether to return a PIL Image (True) or a NumPy array (False).  Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Image.Image or np.ndarray: The generated image of a Dobble playing card.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dobble_card</span> <span class="o">=</span> <span class="n">create_empty_card</span><span class="p">(</span><span class="n">image_size</span><span class="p">)</span>
    <span class="n">num_emojis</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">emoji_list</span><span class="p">)</span>
    <span class="n">packing_data</span> <span class="o">=</span> <span class="n">get_packing_data</span><span class="p">(</span><span class="n">num_emojis</span><span class="p">,</span> <span class="n">packing_type</span><span class="p">,</span> <span class="n">image_size</span><span class="p">)</span>

    <span class="c1"># Place emojis on card</span>
    <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">emoji_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">emoji_list</span><span class="p">):</span>
        <span class="n">emoji_image</span> <span class="o">=</span> <span class="n">rescale_emoji</span><span class="p">(</span><span class="n">load_emoji</span><span class="p">(</span><span class="n">emoji_set</span><span class="p">,</span> <span class="n">emoji_name</span><span class="p">,</span> <span class="n">outline_only</span><span class="p">),</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
        <span class="n">emoji_size</span> <span class="o">=</span> <span class="n">packing_data</span><span class="p">[</span><span class="s1">&#39;sizes&#39;</span><span class="p">][</span><span class="n">count</span><span class="p">]</span>
        <span class="n">emoji_center</span> <span class="o">=</span> <span class="n">packing_data</span><span class="p">[</span><span class="s1">&#39;coordinates&#39;</span><span class="p">][</span><span class="n">count</span><span class="p">]</span>
        <span class="n">rotation_angle</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">359</span><span class="p">)</span>
        <span class="n">dobble_card</span> <span class="o">=</span> <span class="n">place_emoji</span><span class="p">(</span><span class="n">dobble_card</span><span class="p">,</span> <span class="n">emoji_image</span><span class="p">,</span> <span class="n">emoji_size</span><span class="p">,</span> <span class="n">emoji_center</span><span class="p">,</span> <span class="n">rotation_angle</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dobble_card</span> <span class="k">if</span> <span class="n">return_pil</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dobble_card</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>To make sure that this function works as expected, let’s <strong>visualize a few custom playing cards</strong>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">scale</span> <span class="o">=</span> <span class="mf">0.9</span>
<span class="n">card_size</span> <span class="o">=</span> <span class="mi">1024</span>
<span class="n">emoji_set</span> <span class="o">=</span> <span class="s1">&#39;classic-dobble&#39;</span>
<span class="n">emoji_lists</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="s1">&#39;ice&#39;</span><span class="p">,</span> <span class="s1">&#39;green-apple&#39;</span><span class="p">,</span> <span class="s1">&#39;t-rex&#39;</span><span class="p">,</span> <span class="s1">&#39;oncoming-police-car&#39;</span><span class="p">,</span> <span class="s1">&#39;bison&#39;</span><span class="p">],</span>
    <span class="p">[</span><span class="s1">&#39;ice&#39;</span><span class="p">,</span> <span class="s1">&#39;green-apple&#39;</span><span class="p">,</span> <span class="s1">&#39;t-rex&#39;</span><span class="p">,</span> <span class="s1">&#39;oncoming-police-car&#39;</span><span class="p">,</span> <span class="s1">&#39;bison&#39;</span><span class="p">,</span> <span class="s1">&#39;spouting-whale&#39;</span><span class="p">],</span>
    <span class="p">[</span><span class="s1">&#39;ice&#39;</span><span class="p">,</span> <span class="s1">&#39;green-apple&#39;</span><span class="p">,</span> <span class="s1">&#39;t-rex&#39;</span><span class="p">,</span> <span class="s1">&#39;oncoming-police-car&#39;</span><span class="p">,</span> <span class="s1">&#39;bison&#39;</span><span class="p">,</span> <span class="s1">&#39;spouting-whale&#39;</span><span class="p">,</span> <span class="s1">&#39;maple-leaf&#39;</span><span class="p">,</span> <span class="s1">&#39;fire&#39;</span><span class="p">],</span>
    <span class="p">[</span><span class="s1">&#39;ice&#39;</span><span class="p">,</span> <span class="s1">&#39;green-apple&#39;</span><span class="p">,</span> <span class="s1">&#39;t-rex&#39;</span><span class="p">,</span> <span class="s1">&#39;oncoming-police-car&#39;</span><span class="p">,</span> <span class="s1">&#39;bison&#39;</span><span class="p">,</span> <span class="s1">&#39;spouting-whale&#39;</span><span class="p">,</span> <span class="s1">&#39;maple-leaf&#39;</span><span class="p">,</span> <span class="s1">&#39;fire&#39;</span><span class="p">,</span> <span class="s1">&#39;rosette&#39;</span><span class="p">]</span>
    <span class="p">]</span>

<span class="c1"># Visualize different numbers of symbols per card across rows and different packing types across columns</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;reports/figures/packings/packings-with-emojis.png&#39;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">emoji_list</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">emoji_lists</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">packing_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">PACKING_TYPES_DICT</span><span class="p">):</span>
        <span class="n">dobble_card_np</span> <span class="o">=</span> <span class="n">create_dobble_card</span><span class="p">(</span>
            <span class="n">scale</span><span class="p">,</span> <span class="n">card_size</span><span class="p">,</span> <span class="n">packing_type</span><span class="p">,</span> <span class="n">emoji_set</span><span class="p">,</span> <span class="n">emoji_list</span><span class="p">,</span> <span class="n">return_pil</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
        
        <span class="c1"># Make the image fully opaque (i.e., turn transparent background black)</span>
        <span class="n">dobble_card_np</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>
        
        <span class="n">axes</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">dobble_card_np</span><span class="p">)</span>
        <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">packing_type</span><span class="si">}</span><span class="s1">, n=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">emoji_list</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Colored Emojis&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">file_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/23668911e1da0a4868210e33b3d9cbe95403c012137b236ebac242de85b3f73c.png" src="../../_images/23668911e1da0a4868210e33b3d9cbe95403c012137b236ebac242de85b3f73c.png" />
</div>
</div>
<p>Also, let’s see what it looks like if we only use the <strong>outlined emojis</strong>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Visualize different numbers of symbols per card across rows and different packing types across columns</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>

<span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">emoji_list</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">emoji_lists</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">packing_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">PACKING_TYPES_DICT</span><span class="p">):</span>
        <span class="n">dobble_card_np</span> <span class="o">=</span> <span class="n">create_dobble_card</span><span class="p">(</span>
            <span class="n">scale</span><span class="p">,</span> <span class="n">card_size</span><span class="p">,</span> <span class="n">packing_type</span><span class="p">,</span> <span class="n">emoji_set</span><span class="p">,</span> <span class="n">emoji_list</span><span class="p">,</span> <span class="n">return_pil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">outline_only</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        
        <span class="c1"># Make the image fully opaque (i.e., turn transparent background black)</span>
        <span class="n">dobble_card_np</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>
        
        <span class="n">axes</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">dobble_card_np</span><span class="p">)</span>
        <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">packing_type</span><span class="si">}</span><span class="s1">, n=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">emoji_list</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Outlines Only&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/549887bf573f4ec6638ea43a56b4ff431dc32f18c4f9406597247aa5dfc61b4a.png" src="../../_images/549887bf573f4ec6638ea43a56b4ff431dc32f18c4f9406597247aa5dfc61b4a.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">DATA_DIR</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;data/processed&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Next, let’s think for a moment about the <strong>parameters</strong> that we want to be able to control when creating a new deck of playing cards:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">emoji_set</span></code> <strong>Which set of emojis</strong> do we want to use?</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_emojis</span></code> <strong>How many emojis</strong> do we want <strong>on each card</strong>? Remember that this number needs to be equal to <span class="math notranslate nohighlight">\(p^k + 1\)</span> with <span class="math notranslate nohighlight">\(p\)</span> being prime (i.e., an integer that immediately follows a prime power).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">scale</span></code> How do we want to <strong>rescale the emoji images</strong> before placing them on the cards?</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">image_size</span></code> <strong>How large</strong> (in pixels) should each (card) image be?</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">deck_name</span></code> What do we want to call our newly created deck? This will also serve as the <strong>name of the subdirectory</strong> of the directory, where we will store the images.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">outline_only</span></code> Do we want to use the <strong>colored versions</strong> of the emojis <strong>or</strong> just their <strong>outlines</strong>?</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">packing_type</span></code> Do we want to use one <strong>type of circle packing</strong> for all cards or do we want to choose the packing type randomly for each card to have greater variability between cards?</p></li>
</ul>
<p>Finally, here is an <strong>outline of the individual steps</strong> we need to take to create our custom deck of playing cards:</p>
<ol class="arabic simple">
<li><p>Using the <code class="docutils literal notranslate"><span class="pre">deck_name</span></code> parameter, create a subdirectory to store the generated images.</p></li>
<li><p>Compute the incidence matrix of the finite projective plane of the appropriate order (Remember: The order of the projective plane is one less than the number of symbols on each card!). We make use of the <code class="docutils literal notranslate"><span class="pre">compute_incidence_matrix</span></code> function to achieve this.</p></li>
<li><p>Read in the names of all the emojis available in the specified <code class="docutils literal notranslate"><span class="pre">emoji_set</span></code>. We use the <code class="docutils literal notranslate"><span class="pre">get_emoji_names</span></code> function to do so.</p>
<ul class="simple">
<li><p>Make sure that there are enough emojis available in this set! The number of distinct emojis needed in total is derived from the <code class="docutils literal notranslate"><span class="pre">num_emojis</span></code>. If there aren’t enough, throw an error. If there are too many, choose a random subset of the appropriate size.</p></li>
</ul>
</li>
<li><p>Set up a CSV file that will store all the necessary information to create the ground-truth labels later on (i.e., which is the common symbol between any pair of cards?).</p></li>
<li><p>Finally, create the playing cards one by one. This is done as follows:</p>
<ul class="simple">
<li><p>The incidence matrix generated by the <code class="docutils literal notranslate"><span class="pre">compute_incidence_matrix</span></code> function tells us which emojis need to be placed on which card (i.e., the entries in the <span class="math notranslate nohighlight">\(i\)</span>-th row determine the emojis that need to be placed on the <span class="math notranslate nohighlight">\(i\)</span>-th playing card).</p></li>
<li><p>Select the names of the corresponding emojis from the <code class="docutils literal notranslate"><span class="pre">emoji_names</span></code> list that we created earlier using the <code class="docutils literal notranslate"><span class="pre">get_emoji_names</span></code> function.</p></li>
<li><p>Shuffle this list to randomly place the emojis on the card and create the playing card with the <code class="docutils literal notranslate"><span class="pre">create_dobble_card</span></code> function.</p></li>
<li><p>Finally, append all the relevant information about the card that was just generated to the CSV file created earlier.</p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_dobble_deck</span><span class="p">(</span>
        <span class="n">emoji_set</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">num_emojis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">image_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">deck_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">outline_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">packing_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a full set of playing cards (i.e., generate and save images).</span>

<span class="sd">    Args:</span>
<span class="sd">        emoji_set (str): The name of the set of emojis (e.g., &#39;classic-dobble&#39;) to use.</span>
<span class="sd">        num_emojis (int): The number of emojis to place on each card.</span>
<span class="sd">        scale (float): Determines to what extent the emoji should fill the inscribed circle.</span>
<span class="sd">        image_size (int): The size of each square image (of a single playing card) in pixels.</span>
<span class="sd">        deck_name (str): The name of the deck.  Will also be used to create the subdirectory</span>
<span class="sd">            that stores all the generated images.</span>
<span class="sd">        outline_only (bool): Whether to generate playing cards with outline-only emojis.  Defaults to False.</span>
<span class="sd">        packing_type (str): The type of packing to use for placing emojis on the cards.</span>
<span class="sd">            If not provided, a packing type is randomly chosen for each card.  Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[str, str]: A tuple containing the file paths to the generated CSV files that store all</span>
<span class="sd">            information about the playing cards (&#39;deck.csv&#39;) as well as the emoji labels (&#39;emoji_labels.csv&#39;).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">deck_dir</span> <span class="o">=</span> <span class="n">DATA_DIR</span> <span class="o">/</span> <span class="n">deck_name</span>  <span class="c1"># directory to store the images</span>
    <span class="n">csv_dir</span> <span class="o">=</span> <span class="n">deck_dir</span> <span class="o">/</span> <span class="s1">&#39;csv&#39;</span>  <span class="c1"># directory to store all the information about the deck</span>

    <span class="c1"># If the &#39;csv_dir&#39; already exists (i.e., the deck has already been created),</span>
    <span class="c1"># we simply return the two CSV files that would be created by this function</span>
    <span class="k">if</span> <span class="n">csv_dir</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
        <span class="n">deck_csv</span> <span class="o">=</span> <span class="n">csv_dir</span> <span class="o">/</span> <span class="s1">&#39;deck.csv&#39;</span>
        <span class="n">emoji_labels_csv</span> <span class="o">=</span> <span class="n">csv_dir</span> <span class="o">/</span> <span class="s1">&#39;emoji_labels.csv&#39;</span>
        <span class="k">return</span> <span class="n">deck_csv</span><span class="p">,</span> <span class="n">emoji_labels_csv</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">csv_dir</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Compute incidence matrix of corresponding finite projective plane</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">num_emojis</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">incidence_matrix</span> <span class="o">=</span> <span class="n">compute_incidence_matrix</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>

    <span class="c1"># The number of cards in a deck is given by n^2 + n + 1, with n + 1 = # symbols on each card</span>
    <span class="c1"># NOTE: Remember that there are as many distinct symbols in a deck as there are cards</span>
    <span class="n">num_cards</span> <span class="o">=</span> <span class="n">order</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Read in the names of all emojis in the specified &#39;emoji_set&#39;</span>
    <span class="n">emoji_names</span> <span class="o">=</span> <span class="n">get_emoji_names</span><span class="p">(</span><span class="n">emoji_set</span><span class="p">,</span> <span class="n">outline_only</span><span class="p">)</span>

    <span class="c1"># Check if there are enough emojis in the specified subdirectory</span>
    <span class="n">num_emojis_available</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">emoji_names</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_emojis_available</span> <span class="o">&lt;</span> <span class="n">num_cards</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Not enough emojis in the specified set to create the Dobble deck.&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">num_emojis_available</span> <span class="o">&gt;</span> <span class="n">num_cards</span><span class="p">:</span>
        <span class="c1"># If there are more emojis than we need, we randomly choose a subset of the appropriate size</span>
        <span class="n">emoji_names</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">emoji_names</span><span class="p">,</span> <span class="n">num_cards</span><span class="p">)</span>

    <span class="c1"># Create CSV file to store information about the individual emojis and their corresponding labels</span>
    <span class="n">emoji_labels</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;EmojiName&#39;</span><span class="p">:</span> <span class="n">emoji_names</span><span class="p">,</span> <span class="s1">&#39;EmojiLabel&#39;</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">emoji_names</span><span class="p">))})</span>
    <span class="n">emoji_labels_csv</span> <span class="o">=</span> <span class="n">csv_dir</span> <span class="o">/</span> <span class="s1">&#39;emoji_labels.csv&#39;</span>
    <span class="n">emoji_labels</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">emoji_labels_csv</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># If no &#39;packing_type&#39; was provided initially, choose one randomly</span>
    <span class="c1"># each time from the &#39;PACKING_TYPES_DICT&#39; dictionary</span>
    <span class="n">choose_randomly</span> <span class="o">=</span> <span class="n">packing_type</span> <span class="ow">is</span> <span class="kc">None</span>

    <span class="c1"># Create CSV file to store information about the individual cards</span>
    <span class="n">deck_csv</span> <span class="o">=</span> <span class="n">csv_dir</span> <span class="o">/</span> <span class="s1">&#39;deck.csv&#39;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">deck_csv</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">(</span>
            <span class="p">[</span><span class="s1">&#39;FilePath&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;PackingType&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;Emoji&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_emojis</span><span class="p">)]</span>
            <span class="p">)</span>

    <span class="c1"># Create playing cards one-by-one using the incidence matrix to decide which emojis to put on which card</span>
    <span class="c1"># NOTE: len(a) is equivalent to np.shape(a)[0] for N-D arrays with N&gt;=1.</span>
    <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">incidence_matrix</span><span class="p">)):</span>
        <span class="c1"># Find the emojis that are to be placed on the card</span>
        <span class="n">which_emojis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">incidence_matrix</span><span class="p">[</span><span class="n">card</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">emoji_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">emoji_names</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">which_emojis</span><span class="p">]</span>
        <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">emoji_list</span><span class="p">)</span>

        <span class="c1"># If no &#39;packing_type&#39; was provided initially, choose one randomly</span>
        <span class="c1"># from the &#39;PACKING_TYPES_DICT&#39; dictionary</span>
        <span class="k">if</span> <span class="n">choose_randomly</span><span class="p">:</span>
            <span class="n">packing_type</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">PACKING_TYPES_DICT</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="c1"># Create playing card and save in directory</span>
        <span class="n">dobble_card</span> <span class="o">=</span> <span class="n">create_dobble_card</span><span class="p">(</span>
            <span class="n">scale</span><span class="p">,</span>
            <span class="n">image_size</span><span class="p">,</span>
            <span class="n">packing_type</span><span class="p">,</span>
            <span class="n">emoji_set</span><span class="p">,</span>
            <span class="n">emoji_list</span><span class="p">,</span>
            <span class="n">outline_only</span>
            <span class="p">)</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">deck_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">card</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">:</span><span class="s1">03d</span><span class="si">}</span><span class="s1">.png&#39;</span>
        <span class="n">file_path</span> <span class="o">=</span> <span class="n">deck_dir</span> <span class="o">/</span> <span class="n">file_name</span>
        <span class="n">dobble_card</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>

        <span class="c1"># Write card information to the CSV file</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">deck_csv</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="n">file_path</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">packing_type</span><span class="p">]</span> <span class="o">+</span> <span class="n">emoji_list</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">deck_csv</span><span class="p">,</span> <span class="n">emoji_labels_csv</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s test this function and create and then visualize our first custom deck of <em>Dobble</em> playing cards!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># We set a random seed for reproducibility</span>
<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">33</span><span class="p">)</span>

<span class="n">emoji_set</span> <span class="o">=</span> <span class="s1">&#39;classic-dobble&#39;</span>
<span class="n">num_emojis</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">image_size</span> <span class="o">=</span> <span class="mi">224</span>
<span class="n">deck_name</span> <span class="o">=</span> <span class="s1">&#39;classic-dobble&#39;</span>

<span class="n">deck_csv</span><span class="p">,</span> <span class="n">emoji_labels_csv</span> <span class="o">=</span> <span class="n">create_dobble_deck</span><span class="p">(</span>
    <span class="n">emoji_set</span><span class="p">,</span>
    <span class="n">num_emojis</span><span class="p">,</span>
    <span class="n">scale</span><span class="p">,</span>
    <span class="n">image_size</span><span class="p">,</span>
    <span class="n">deck_name</span>
    <span class="p">)</span>

<span class="c1"># Set up plot</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>

<span class="c1"># Extract file paths to images</span>
<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;reports/figures/cards/classic-dobble-deck.png&#39;</span><span class="p">)</span>
<span class="n">image_paths</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">deck_csv</span><span class="p">)[</span><span class="s1">&#39;FilePath&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

<span class="c1"># Display playing cards</span>
<span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_paths</span><span class="p">):</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">image_paths</span><span class="p">[</span><span class="n">count</span><span class="p">])</span>
        <span class="n">image_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image_np</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Full Deck of Playing Cards&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">file_path</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">file_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/87a92a556d9afde560b60f47ca33815ccab0d44556eed72b982bc8b29d6761ee.png" src="../../_images/87a92a556d9afde560b60f47ca33815ccab0d44556eed72b982bc8b29d6761ee.png" />
</div>
</div>
</section>
<section id="pairs-of-cards">
<h3>Pairs of Cards<a class="headerlink" href="#pairs-of-cards" title="Link to this heading">#</a></h3>
<p>When training networks, we want to pass images that display pairs of playing cards so that the network has to find the unique emoji shared by the two playing cards in the image. To achieve this, we will create a square image of a uniformly colored background, divide it into four quadrants of equal size, and then place two playing cards into two of these quadrants.</p>
<p>First, let’s write a function that computes the coordinates of where the playing cards need to be positioned based on the quadrant that they are supposed to be placed in.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compute_quadrant_coordinates</span><span class="p">(</span>
        <span class="n">quadrant</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">image_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the coordinates of a specified quadrant within a square image.</span>

<span class="sd">    Args:</span>
<span class="sd">        quadrant (int): The quadrant number, ranging from 1 to 4.</span>
<span class="sd">        image_size (int): The size of the square image.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[int, int]: The upper left coordinates (x, y) of the specified quadrant within the square image.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If an invalid &#39;quadrant&#39; (number) is provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">quadrant_size</span> <span class="o">=</span> <span class="n">image_size</span> <span class="o">//</span> <span class="mi">2</span>
    
    <span class="k">if</span> <span class="n">quadrant</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># upper right</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="p">(</span><span class="n">quadrant_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">quadrant</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># upper left</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">quadrant</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># lower left</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">quadrant_size</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">quadrant</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>  <span class="c1"># lower right</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="p">(</span><span class="n">quadrant_size</span><span class="p">,</span> <span class="n">quadrant_size</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid quadrant. Please provide a value from 1 to 4.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">coordinates</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we write a function that returns the desired <strong>images of pairs of cards</strong>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_tile_image</span><span class="p">(</span>
        <span class="n">image1</span><span class="p">:</span> <span class="n">Image</span><span class="o">.</span><span class="n">Image</span><span class="p">,</span>
        <span class="n">image2</span><span class="p">:</span> <span class="n">Image</span><span class="o">.</span><span class="n">Image</span><span class="p">,</span>
        <span class="n">quadrants</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">bg_color</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_pil</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Image</span><span class="o">.</span><span class="n">Image</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a tile image by combining two square images based on the specified quadrants.</span>

<span class="sd">    Args:</span>
<span class="sd">        image1 (Image.Image): The first input image to place on the tile image.</span>
<span class="sd">        image2 (Image.Image): The second input image to place on the tile image.</span>
<span class="sd">        quadrants (tuple[int, int]): Tuple of integers from 1 to 4 representing the quadrants in which</span>
<span class="sd">            the two images will be placed.</span>
<span class="sd">        bg_color (tuple[int, int, int]): The RGB color tuple for the background color.  Defaults to None.</span>
<span class="sd">        return_pil (bool): Whether to return a PIL Image (True) or a NumPy array (False).  Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Image.Image or np.ndarray: The generated tile image.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If two identical quadrants are provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">quadrants</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">quadrants</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Two identical quadrants provided. Images would overlap.&#39;</span><span class="p">)</span>

    <span class="n">tile_image_size</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">image1</span><span class="o">.</span><span class="n">width</span>

    <span class="c1"># Choose random background color if &#39;bg_color&#39; was not specified</span>
    <span class="k">if</span> <span class="n">bg_color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bg_color</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">))</span>

    <span class="n">tile_image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;RGBA&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">tile_image_size</span><span class="p">,</span> <span class="n">tile_image_size</span><span class="p">),</span> <span class="n">bg_color</span><span class="p">)</span>

    <span class="n">image1_pos</span> <span class="o">=</span> <span class="n">compute_quadrant_coordinates</span><span class="p">(</span><span class="n">quadrants</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tile_image_size</span><span class="p">)</span>
    <span class="n">image2_pos</span> <span class="o">=</span> <span class="n">compute_quadrant_coordinates</span><span class="p">(</span><span class="n">quadrants</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tile_image_size</span><span class="p">)</span>

    <span class="n">tile_image</span><span class="o">.</span><span class="n">paste</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image1_pos</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">image1</span><span class="p">)</span>
    <span class="n">tile_image</span><span class="o">.</span><span class="n">paste</span><span class="p">(</span><span class="n">image2</span><span class="p">,</span> <span class="n">image2_pos</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">image2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tile_image</span> <span class="k">if</span> <span class="n">return_pil</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tile_image</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s make sure that this function works as expected. For each possible combination of quadrants, we choose two arbitrary cards each from our set of playing cards that we have already created and then arrange them into a single image using the <code class="docutils literal notranslate"><span class="pre">create_tile_image</span></code> function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># NOTE: The file paths to the images of our playing cards are still stored in the &#39;image_paths&#39; variable!</span>
<span class="n">num_cards</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_paths</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># Again, we set random seeds for reproducibility</span>
<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">41</span><span class="p">)</span>  <span class="c1"># identical playing cards</span>
<span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">41</span><span class="p">)</span>  <span class="c1"># identical background colors</span>

<span class="k">for</span> <span class="n">pos1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">pos2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pos1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
        <span class="n">image1_idx</span><span class="p">,</span> <span class="n">image2_idx</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_cards</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">image1</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">image_paths</span><span class="p">[</span><span class="n">image1_idx</span><span class="p">])</span>
        <span class="n">image2</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">image_paths</span><span class="p">[</span><span class="n">image2_idx</span><span class="p">])</span>
        <span class="n">quadrants</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos1</span><span class="p">,</span> <span class="n">pos2</span><span class="p">)</span>
        <span class="n">tile_image_np</span> <span class="o">=</span> <span class="n">create_tile_image</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">quadrants</span><span class="p">,</span> <span class="n">return_pil</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">tile_image_np</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;quadrants: </span><span class="si">{</span><span class="n">quadrants</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Quadrant Combinations&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/b49f741c4148c1245c7479ef9d73b725c52c2421a1e764323e7deeddec625f3c.png" src="../../_images/b49f741c4148c1245c7479ef9d73b725c52c2421a1e764323e7deeddec625f3c.png" />
</div>
</div>
</section>
</section>
<section id="setting-up-a-deep-learning-pipeline">
<h2>Setting up a Deep Learning Pipeline<a class="headerlink" href="#setting-up-a-deep-learning-pipeline" title="Link to this heading">#</a></h2>
<p>We can now create custom data (images of custom <em>Dobble</em> playing cards) to use in our deep learning project. Next, let’s prepare all the necessary tools that we need to set up our deep learning pipeline (e.g., dataset generation, training routines, etc.).</p>
<section id="generating-datasets">
<h3>Generating Datasets<a class="headerlink" href="#generating-datasets" title="Link to this heading">#</a></h3>
<p>So far, when we create a new set of playing cards (i.e., images), we automatically generate two CSV files: one containing general information about the deck (e.g., where are the images stored, which emojis are placed on which card) and one containing a mapping between integer labels and emoji names. What we also need is a <strong>CSV file that contains all possible pairs of playing cards</strong>. This is exactly what we’ll take care of next.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">pair_up_cards</span><span class="p">(</span>
        <span class="n">deck_csv</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">emoji_labels_csv</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a CSV file containing all possible combinations of playing cards in a Dobble deck.</span>

<span class="sd">    Args:</span>
<span class="sd">        deck_csv (str): The file path to the CSV file generated by the &#39;create_dobble_deck&#39; function.</span>
<span class="sd">        emoji_labels_csv (str): The file path to the CSV file generated by the &#39;create_dobble_deck&#39; function.</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: The file path to the created CSV file &#39;pairs.csv&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if &#39;pairs&#39; CSV has already been created</span>
    <span class="n">csv_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">deck_csv</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span>
    <span class="n">pairs_csv</span> <span class="o">=</span> <span class="n">csv_dir</span> <span class="o">/</span> <span class="s1">&#39;pairs.csv&#39;</span>
    
    <span class="k">if</span> <span class="n">pairs_csv</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">pairs_csv</span>

    <span class="c1"># Read the card information from the &#39;deck_csv&#39; file into a list of lists,</span>
    <span class="c1"># where inner lists correspond to rows of the CSV file</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">deck_csv</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="nb">next</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span>  <span class="c1"># Skip header</span>
        <span class="n">deck_info</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span>

    <span class="c1"># Read the mapping information (i.e., emoji names to integers) from the CSV file &#39;emoji_labels_csv&#39;</span>
    <span class="n">emoji_labels_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">emoji_labels_csv</span><span class="p">)</span>

    <span class="c1"># Generate all combinations of pairs of cards (ignoring the order of cards)</span>
    <span class="n">card_pairs</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">deck_info</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pairs_csv</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="s1">&#39;Card1Path&#39;</span><span class="p">,</span> <span class="s1">&#39;Card2Path&#39;</span><span class="p">,</span> <span class="s1">&#39;CommonEmojiLabel&#39;</span><span class="p">])</span>

        <span class="c1"># Iterate over each pair of cards</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">card_pairs</span><span class="p">:</span>
            <span class="n">card1_path</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Extract file path of the first card</span>
            <span class="n">card2_path</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Extract file path of the second card</span>
            <span class="n">emojis1</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span>    <span class="c1"># Extract names of emojis that are placed on the first card</span>
            <span class="n">emojis2</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span>    <span class="c1"># Extract names of emojis that are placed on the second card</span>

            <span class="c1"># Find the common emoji between the two cards</span>
            <span class="n">common_emoji</span> <span class="o">=</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">emojis1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">emojis2</span><span class="p">))</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">common_emoji_label</span> <span class="o">=</span> <span class="n">emoji_labels_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                <span class="n">emoji_labels_df</span><span class="p">[</span><span class="s1">&#39;EmojiName&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">common_emoji</span><span class="p">,</span> <span class="s1">&#39;EmojiLabel&#39;</span>
                <span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Write data to CSV file</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="n">card1_path</span><span class="p">,</span> <span class="n">card2_path</span><span class="p">,</span> <span class="n">common_emoji_label</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">pairs_csv</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s create the <strong>CSV file that contains all the possible pairs of cards</strong> of our recently created Dobble deck. If everything works as expected, this CSV file should contain <span class="math notranslate nohighlight">\((57 * 56) / 2 = 1596\)</span> entries (not counting the header).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pairs_csv</span> <span class="o">=</span> <span class="n">pair_up_cards</span><span class="p">(</span><span class="n">deck_csv</span><span class="p">,</span> <span class="n">emoji_labels_csv</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we simply combine the two functions <code class="docutils literal notranslate"><span class="pre">create_dobble_deck</span></code> and <code class="docutils literal notranslate"><span class="pre">pair_up_cards</span></code> into a single function that (if not done already) creates a full deck of custom <em>Dobble</em> playing cards and also creates all the necessary CSV files (deck information, emoji labels mapping, and pairs of cards) in one go.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">prepare_dobble_dataset</span><span class="p">(</span>
        <span class="n">emoji_set</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">num_emojis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">image_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">deck_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">outline_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">packing_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Prepare a full dataset of playing cards (i.e., generate and save images, pair up playing cards).</span>

<span class="sd">    Args:</span>
<span class="sd">        emoji_set (str): The name of the set of emojis (e.g., &#39;classic-dobble&#39;) to use.</span>
<span class="sd">        num_emojis (int): The number of emojis to place on each card.</span>
<span class="sd">        scale (float): Determines to what extent the emoji should fill the inscribed circle.</span>
<span class="sd">        image_size (int): The size of each square image (of a single playing card) in pixels.</span>
<span class="sd">        deck_name (str): The name of the deck.  Will also be used to create the subdirectory</span>
<span class="sd">            that stores all the generated images.</span>
<span class="sd">        outline_only (bool): Whether to generate playing cards with outline-only emojis.  Defaults to False.</span>
<span class="sd">        packing_type (str): The type of packing to use for placing emojis on the cards.</span>
<span class="sd">            If not provided, a packing type is randomly chosen for each card.  Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[str, str, str]: A tuple containing the file paths to the generated CSV files that store all</span>
<span class="sd">            information about the playing cards (&#39;deck.csv&#39;), the emoji labels (&#39;emoji_labels.csv&#39;),</span>
<span class="sd">            and all pairs of cards (&#39;pairs.csv&#39;), in that order.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">deck_csv</span><span class="p">,</span> <span class="n">emoji_labels_csv</span> <span class="o">=</span> <span class="n">create_dobble_deck</span><span class="p">(</span>
        <span class="n">emoji_set</span><span class="p">,</span> <span class="n">num_emojis</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">image_size</span><span class="p">,</span> <span class="n">deck_name</span><span class="p">,</span> <span class="n">outline_only</span><span class="p">,</span> <span class="n">packing_type</span>
        <span class="p">)</span>
    <span class="n">pairs_csv</span> <span class="o">=</span> <span class="n">pair_up_cards</span><span class="p">(</span><span class="n">deck_csv</span><span class="p">,</span> <span class="n">emoji_labels_csv</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">deck_csv</span><span class="p">,</span> <span class="n">emoji_labels_csv</span><span class="p">,</span> <span class="n">pairs_csv</span>
</pre></div>
</div>
</div>
</div>
<p>As always, let’s double-check that this function works as expected!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">emoji_set</span> <span class="o">=</span> <span class="s1">&#39;classic-dobble&#39;</span>
<span class="n">num_emojis</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">scale</span> <span class="o">=</span> <span class="mf">0.9</span>
<span class="n">image_size</span> <span class="o">=</span> <span class="mi">224</span>
<span class="n">deck_name</span> <span class="o">=</span> <span class="s1">&#39;classic-dobble&#39;</span>

<span class="n">csv_files</span> <span class="o">=</span> <span class="n">prepare_dobble_dataset</span><span class="p">(</span>
    <span class="n">emoji_set</span><span class="p">,</span> <span class="n">num_emojis</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">image_size</span><span class="p">,</span> <span class="n">deck_name</span>
    <span class="p">)</span>

<span class="k">for</span> <span class="n">csv_file</span> <span class="ow">in</span> <span class="n">csv_files</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">csv_file</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>data/processed/classic-dobble/csv/deck.csv
data/processed/classic-dobble/csv/emoji_labels.csv
data/processed/classic-dobble/csv/pairs.csv
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">pairs_csv</span></code> file that we created earlier (which is also contained as the last entry in the <code class="docutils literal notranslate"><span class="pre">csv_files</span></code> tuple) describes the full dataset that we can work with. For training purposes, we want to <strong>split this dataset into three subsets</strong> that can be used for training, validation, and testing.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">split_dataset</span><span class="p">(</span>
        <span class="n">dataset_csv</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">train_ratio</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">val_ratio</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Split a dataset given by a CSV file into three subsets: train, validation, and test.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_csv (str): Path to the original CSV file.</span>
<span class="sd">        train_ratio (float): Proportion of the dataset for the training set (between 0 and 1).</span>
<span class="sd">        val_ratio (float): Proportion of the dataset for the validation set (between 0 and 1).</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[str, str, str]: A tuple containing the file paths for the train, validation, and test CSV files.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the sum of &#39;train_ratio&#39; and &#39;val_ratio&#39; is greater than 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">train_ratio</span> <span class="o">+</span> <span class="n">val_ratio</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The sum of &#39;train_ratio&#39; and &#39;val_ratio&#39; cannot exceed 1.&quot;</span><span class="p">)</span>

    <span class="c1"># Read the CSV file into a pandas DataFrame</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">dataset_csv</span><span class="p">)</span>

    <span class="c1"># Randomly shuffle the DataFrame&#39;s rows</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">frac</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Calculate the number of samples for each subset</span>
    <span class="n">num_all</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="n">num_train</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_all</span> <span class="o">*</span> <span class="n">train_ratio</span><span class="p">)</span>
    <span class="n">num_val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_all</span> <span class="o">*</span> <span class="n">val_ratio</span><span class="p">)</span>

    <span class="c1"># Split into train, validation, and test subsets</span>
    <span class="n">train_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[:</span><span class="n">num_train</span><span class="p">]</span>
    <span class="n">val_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">num_train</span><span class="p">:</span><span class="n">num_train</span> <span class="o">+</span> <span class="n">num_val</span><span class="p">]</span>
    <span class="n">test_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">num_train</span> <span class="o">+</span> <span class="n">num_val</span><span class="p">:]</span>

    <span class="c1"># Extract the directory path of the &#39;dataset_csv&#39; file and construct file paths for the output CSV files</span>
    <span class="n">dir_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">dataset_csv</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span>
    <span class="n">train_csv</span> <span class="o">=</span> <span class="n">dir_path</span> <span class="o">/</span> <span class="s1">&#39;train.csv&#39;</span>
    <span class="n">val_csv</span> <span class="o">=</span> <span class="n">dir_path</span> <span class="o">/</span> <span class="s1">&#39;val.csv&#39;</span>
    <span class="n">test_csv</span> <span class="o">=</span> <span class="n">dir_path</span> <span class="o">/</span> <span class="s1">&#39;test.csv&#39;</span>

    <span class="c1"># Write the subsets to separate CSV files</span>
    <span class="n">train_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">train_csv</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">val_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">val_csv</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">test_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">test_csv</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">train_csv</span><span class="p">,</span> <span class="n">val_csv</span><span class="p">,</span> <span class="n">test_csv</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s test this function to see if it works as expected.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">train_ratio</span> <span class="o">=</span> <span class="mf">0.7</span>  <span class="c1"># 70 % of the data will be used for training purposes</span>
<span class="n">val_ratio</span> <span class="o">=</span> <span class="mf">0.15</span>  <span class="c1"># 15 % of the data will be used for validation purposes</span>

<span class="n">dataset_csvs</span> <span class="o">=</span> <span class="n">split_dataset</span><span class="p">(</span><span class="n">pairs_csv</span><span class="p">,</span> <span class="n">train_ratio</span><span class="p">,</span> <span class="n">val_ratio</span><span class="p">)</span>

<span class="k">for</span> <span class="n">dataset_csv</span> <span class="ow">in</span> <span class="n">dataset_csvs</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">dataset_csv</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>data/processed/classic-dobble/csv/train.csv
data/processed/classic-dobble/csv/val.csv
data/processed/classic-dobble/csv/test.csv
</pre></div>
</div>
</div>
</div>
<p>At this point, we have prepared all of the data so that it can be used to train a network. Next, we define a <strong>custom dataset class</strong> that we’ll name <code class="docutils literal notranslate"><span class="pre">DobbleDataset</span></code>. This class takes as input the path to the CSV file holding the dataset information (e.g., the <code class="docutils literal notranslate"><span class="pre">train_csv</span></code>, <code class="docutils literal notranslate"><span class="pre">val_csv</span></code>, or <code class="docutils literal notranslate"><span class="pre">test_csv</span></code> file paths generated by the <code class="docutils literal notranslate"><span class="pre">split_dataset</span></code> function), a background color for the tile images of pairs of cards, a transform that is applied to the images of the individual playing cards, and two transforms that are sequentially applied to the final tile image. Note that the last four parameters are optional. If any transform is not provided, then the corresponding transformation is simply not performed. If the background color is not supplied, it is chosen randomly by the <code class="docutils literal notranslate"><span class="pre">create_tile_image</span></code> function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DobbleDataset</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dataset class for the Dobble game, containing pairs of card images and corresponding common emoji labels.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_csv (str): The path to the CSV file containing information about the dataset (i.e., pairs of cards and</span>
<span class="sd">            label of common emoji).</span>
<span class="sd">        bg_color (tuple[int, int, int]): The RGB color tuple for the background color of the tile images.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        individual_transform (transforms.Compose): A composition of transforms to be applied to the individual card</span>
<span class="sd">            images.  Defaults to None.</span>
<span class="sd">        tile_transform (transforms.Compose): A composition of transforms to be applied to the tile images.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        preprocess (transforms.Compose): A composition of transforms to be applied to the final images (i.e., after the</span>
<span class="sd">            &#39;tile_transform&#39; has been applied).  Defaults to None.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        image_paths (pd.DataFrame): A Pandas DataFrame containing the paths to the images of the two cards in each</span>
<span class="sd">            pair of cards.</span>
<span class="sd">        labels (pd.Series): A Pandas Series containing the labels of the common emoji for each pair of cards.</span>
<span class="sd">        bg_color (tuple[int, int, int]): The RGB color tuple for the background color of the tile images.</span>
<span class="sd">        individual_transform (transforms.Compose): A composition of transforms to be applied to the individual card</span>
<span class="sd">            images.</span>
<span class="sd">        tile_transform (transforms.Compose): A composition of transforms to be applied to the tile images.</span>
<span class="sd">        preprocess (transforms.Compose): A composition of transforms to be applied to the final images (i.e., after the</span>
<span class="sd">            &#39;tile_transform&#39; has been applied).</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; dataset = DobbleDataset(</span>
<span class="sd">                dataset_csv=&#39;data/processed/classic-dobble/csv/train.csv&#39;,</span>
<span class="sd">                individual_transform=transforms.Compose([</span>
<span class="sd">                    transforms.RandomRotation(30),</span>
<span class="sd">                    transforms.RandomHorizontalFlip()</span>
<span class="sd">                    ]),</span>
<span class="sd">                tile_transform=transforms.ColorJitter(</span>
<span class="sd">                    brightness=0.2,</span>
<span class="sd">                    contrast=0.2,</span>
<span class="sd">                    saturation=0.2,</span>
<span class="sd">                    hue=0.1</span>
<span class="sd">                    ),</span>
<span class="sd">                preprocess=transforms.Compose([</span>
<span class="sd">                    transforms.Resize((224, 224)),</span>
<span class="sd">                    transforms.ToImage(),</span>
<span class="sd">                    transforms.ToDtype(torch.float32, scale=True)</span>
<span class="sd">                    ])</span>
<span class="sd">                )</span>
<span class="sd">        &gt;&gt;&gt; len(dataset)</span>
<span class="sd">        57</span>
<span class="sd">        &gt;&gt;&gt; image, label = dataset[0]</span>
<span class="sd">        &gt;&gt;&gt; image.shape</span>
<span class="sd">        torch.Size([3, 224, 224])</span>
<span class="sd">        &gt;&gt;&gt; label</span>
<span class="sd">        53</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">dataset_csv</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">bg_color</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">individual_transform</span><span class="p">:</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">tile_transform</span><span class="p">:</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">preprocess</span><span class="p">:</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image_paths</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">dataset_csv</span><span class="p">)[[</span><span class="s1">&#39;Card1Path&#39;</span><span class="p">,</span> <span class="s1">&#39;Card2Path&#39;</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">dataset_csv</span><span class="p">)[</span><span class="s1">&#39;CommonEmojiLabel&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bg_color</span> <span class="o">=</span> <span class="n">bg_color</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">individual_transform</span> <span class="o">=</span> <span class="n">individual_transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_transform</span> <span class="o">=</span> <span class="n">tile_transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preprocess</span> <span class="o">=</span> <span class="n">preprocess</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="n">card1_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_paths</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s1">&#39;Card1Path&#39;</span><span class="p">]</span>
        <span class="n">card2_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_paths</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s1">&#39;Card2Path&#39;</span><span class="p">]</span>
        <span class="n">card1_image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">card1_path</span><span class="p">)</span>
        <span class="n">card2_image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">card2_path</span><span class="p">)</span>

        <span class="c1"># Apply individual transforms to the card images if provided</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">individual_transform</span><span class="p">:</span>
            <span class="n">card1_image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">individual_transform</span><span class="p">(</span><span class="n">card1_image</span><span class="p">)</span>
            <span class="n">card2_image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">individual_transform</span><span class="p">(</span><span class="n">card2_image</span><span class="p">)</span>

        <span class="n">card1_quadrant</span><span class="p">,</span> <span class="n">card2_quadrant</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">create_tile_image</span><span class="p">(</span>
            <span class="n">card1_image</span><span class="p">,</span> <span class="n">card2_image</span><span class="p">,</span> <span class="p">(</span><span class="n">card1_quadrant</span><span class="p">,</span> <span class="n">card2_quadrant</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bg_color</span>
            <span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s1">&#39;RGB&#39;</span><span class="p">)</span>

        <span class="c1"># Apply tile transform to the tile image if provided</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_transform</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_transform</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

        <span class="c1"># Apply preprocessing to obtain final image</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preprocess</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preprocess</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

        <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">image</span><span class="p">,</span> <span class="n">label</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">label</span></code> that is returned by the <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> method of the <code class="docutils literal notranslate"><span class="pre">DobbleDataset</span></code> class is an integer from 0 to the number of emojis in the <em>Dobble</em> deck (which coincides with the total number of playing cards) minus 1. It will be convenient for us to translate this integer back to the name of the emoji that it corresponds to. To achieve this, we write a little helper function that takes as input the <code class="docutils literal notranslate"><span class="pre">emoji_labels_csv</span></code> file generated by the <code class="docutils literal notranslate"><span class="pre">create_dobble_deck</span></code> and returns a dictionary mapping integer labels to emoji names.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_labels_dict</span><span class="p">(</span><span class="n">emoji_labels_csv</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a dictionary mapping emoji labels (integers starting from 0) to their corresponding names.</span>

<span class="sd">    Args:</span>
<span class="sd">        emoji_labels_csv (str): The file path to the CSV file containing emoji labels and names.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary mapping emoji labels to names.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">emoji_labels_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">emoji_labels_csv</span><span class="p">)</span>
    <span class="n">labels_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">emoji_labels_df</span><span class="p">[</span><span class="s1">&#39;EmojiLabel&#39;</span><span class="p">],</span> <span class="n">emoji_labels_df</span><span class="p">[</span><span class="s1">&#39;EmojiName&#39;</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">labels_dict</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s create our <code class="docutils literal notranslate"><span class="pre">labels_dict</span></code> and print its first 10 entries.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">labels_dict</span> <span class="o">=</span> <span class="n">create_labels_dict</span><span class="p">(</span><span class="n">emoji_labels_csv</span><span class="p">)</span>

<span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">labels_dict</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0: anchor
1: baby-bottle
2: bison
3: bomb
4: cactus
5: candle
6: carrot
7: cheese-wedge
8: chess-pawn
9: clown-face
</pre></div>
</div>
</div>
</div>
</section>
<section id="utility-functions">
<h3>Utility Functions<a class="headerlink" href="#utility-functions" title="Link to this heading">#</a></h3>
<p>Before we move on to learning rate schedules as well as training and testing routines, we implement a few utility functions that we’ll be using later on.</p>
<p>We start by defining our custom <code class="docutils literal notranslate"><span class="pre">accuracy</span></code> function, which gives us slightly more flexibility when <strong>computing the accuracy of a model’s predictions</strong> compared to just calculating the fraction of samples the model predicted correctly.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">accuracy</span><span class="p">(</span>
        <span class="n">output</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">top_k</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the accuracy of a model&#39;s output predictions.</span>

<span class="sd">    Args:</span>
<span class="sd">        output (torch.Tensor): Model&#39;s output tensor.</span>
<span class="sd">        target (torch.Tensor): Target tensor containing the ground truth labels.</span>
<span class="sd">        top_k (tuple[int, ...]): Tuple of integers representing the top-k values to consider for accuracy calculation.</span>
<span class="sd">            Defaults to (1,).</span>

<span class="sd">    Returns:</span>
<span class="sd">        list[torch.Tensor]: A list of torch.Tensor objects representing accuracy values for</span>
<span class="sd">            each top-k value specified.</span>

<span class="sd">    Note:</span>
<span class="sd">        The top-k accuracy considers whether the correct label is among the top-k predicted labels.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; output = torch.tensor([[0.2, 0.3, 0.5], [0.7, 0.1, 0.2]])</span>
<span class="sd">        &gt;&gt;&gt; target = torch.tensor([1, 1])</span>
<span class="sd">        &gt;&gt;&gt; accuracy(output, target, top_k=(1, 2, 3))</span>
<span class="sd">        [tensor([0.]), tensor([50.]), tensor([100.])]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
        <span class="n">max_k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">top_k</span><span class="p">)</span>  <span class="c1"># max &#39;top_k&#39; value</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># number of labels (= number of samples in the batch)</span>

        <span class="c1"># Compute indices of top k values for each prediction</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">prediction</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">topk</span><span class="p">(</span><span class="n">max_k</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">largest</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">prediction</span> <span class="o">=</span> <span class="n">prediction</span><span class="o">.</span><span class="n">t</span><span class="p">()</span>

        <span class="c1"># Check whether predictions match target (i.e., ground truth labels)</span>
        <span class="n">correct</span> <span class="o">=</span> <span class="n">prediction</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">prediction</span><span class="p">))</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">top_k</span><span class="p">:</span>
            <span class="n">correct_k</span> <span class="o">=</span> <span class="n">correct</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">correct_k</span><span class="o">.</span><span class="n">mul_</span><span class="p">(</span><span class="mf">100.</span> <span class="o">/</span> <span class="n">batch_size</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
<p>The next function allows us to <strong>re-print the training logs</strong> that were initially printed out during training and collected in a <code class="docutils literal notranslate"><span class="pre">train_logs</span></code> dictionary.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">reprint_logs</span><span class="p">(</span>
        <span class="n">train_logs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span>
        <span class="n">start_after</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">print_freq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Re-print training logs.</span>

<span class="sd">    Args:</span>
<span class="sd">        train_logs (dict[str, list[float]]): A dictionary containing training logs.</span>
<span class="sd">        start_after (int): The epoch after which to start re-printing the training logs.  Defaults to 0.</span>
<span class="sd">        print_freq (int): Frequency (in number of epochs) at which to re-print information about</span>
<span class="sd">            the training progress.  Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_epochs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">train_logs</span><span class="p">[</span><span class="s1">&#39;train_loss&#39;</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">print_freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">print_freq</span> <span class="o">=</span> <span class="n">num_epochs</span> <span class="o">//</span> <span class="mi">10</span>

    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_after</span><span class="p">,</span> <span class="n">num_epochs</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">print_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Epoch [</span><span class="si">{:03d}</span><span class="s1">/</span><span class="si">{:03d}</span><span class="s1">]   Train   Loss=</span><span class="si">{:.4f}</span><span class="s1">   Acc=</span><span class="si">{:.2f}</span><span class="s1">    Val   Loss=</span><span class="si">{:.4f}</span><span class="s1">   Acc=</span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>                        <span class="c1"># epoch number</span>
                <span class="n">num_epochs</span><span class="p">,</span>                       <span class="c1"># total number of epochs</span>
                <span class="n">train_logs</span><span class="p">[</span><span class="s1">&#39;train_loss&#39;</span><span class="p">][</span><span class="n">epoch</span><span class="p">],</span>  <span class="c1"># loss (training)</span>
                <span class="n">train_logs</span><span class="p">[</span><span class="s1">&#39;train_acc&#39;</span><span class="p">][</span><span class="n">epoch</span><span class="p">],</span>   <span class="c1"># accuracy (training)</span>
                <span class="n">train_logs</span><span class="p">[</span><span class="s1">&#39;val_loss&#39;</span><span class="p">][</span><span class="n">epoch</span><span class="p">],</span>    <span class="c1"># loss (validation)</span>
                <span class="n">train_logs</span><span class="p">[</span><span class="s1">&#39;val_acc&#39;</span><span class="p">][</span><span class="n">epoch</span><span class="p">]</span>      <span class="c1"># accuracy (validation)</span>
                <span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>We now implement a function that <strong>visualizes the results</strong> (i.e., loss and accuracy during training and validation) <strong>of training</strong> a network.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_loss_and_accuracy</span><span class="p">(</span>
        <span class="n">train_logs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span>
        <span class="n">save_plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">figure_title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Plot the loss and accuracy curves for training and validation.</span>

<span class="sd">    Args:</span>
<span class="sd">        train_logs (dict[str, list[float]]): A dictionary containing training logs.</span>
<span class="sd">        save_plot (bool): Whether to save the generated plot.  Defaults to False.</span>
<span class="sd">        figure_title (str): The title of the saved figure.  Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_epochs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">train_logs</span><span class="p">[</span><span class="s1">&#39;train_loss&#39;</span><span class="p">])</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_epochs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">train_logs</span><span class="p">[</span><span class="s1">&#39;train_loss&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">train_logs</span><span class="p">[</span><span class="s1">&#39;train_acc&#39;</span><span class="p">])</span>  <span class="c1"># training</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_epochs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">train_logs</span><span class="p">[</span><span class="s1">&#39;val_loss&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">train_logs</span><span class="p">[</span><span class="s1">&#39;val_acc&#39;</span><span class="p">])</span>  <span class="c1"># validation</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Epoch&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Loss&#39;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;Accuracy (in %)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Loss&#39;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;Accuracy&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;Training&#39;</span><span class="p">,</span> <span class="s1">&#39;Validation&#39;</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;major&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#DDDDDD&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;minor&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#EEEEEE&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">minorticks_on</span><span class="p">()</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Training Results&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">save_plot</span><span class="p">:</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="n">figure_title</span> <span class="k">if</span> <span class="n">figure_title</span> <span class="k">else</span> <span class="s1">&#39;training-results.png&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="s1">&#39;reports/figures/results&#39;</span><span class="p">,</span> <span class="n">file_name</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Plot saved successfully.&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Error while saving the plot: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Next, <code class="docutils literal notranslate"><span class="pre">calculate_mean_std</span></code> <strong>computes the mean and standard deviation per color channel of a given dataset</strong> (provided through a dataloader).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">calculate_mean_std</span><span class="p">(</span><span class="n">loader</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the mean and standard deviation of pixel values per channel from a given dataloader.</span>

<span class="sd">    Args:</span>
<span class="sd">        loader (torch.utils.data.DataLoader): A dataloader that provides batches of images.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[list[float], list[float]]: A tuple containing the mean and standard deviations of each channel.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
        <span class="n">running_sum</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># per channel</span>
        <span class="n">running_squared_sum</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># per channel</span>
        <span class="n">total_pixels</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># per channel</span>

        <span class="k">for</span> <span class="n">images</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">loader</span><span class="p">:</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">images</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
            <span class="n">total_pixels</span> <span class="o">+=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">h</span> <span class="o">*</span> <span class="n">w</span>

            <span class="n">running_sum</span> <span class="o">+=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  <span class="c1"># sum of pixel values per channel</span>
            <span class="n">running_squared_sum</span> <span class="o">+=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">images</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  <span class="c1"># sum of squared pixel values per channel</span>

        <span class="c1"># Calculate the sample mean and corrected sample standard deviation for each channel</span>
        <span class="c1"># NOTE: We&#39;re using the  *corrected sample standard deviation*, i.e., we&#39;re applying Bessel&#39;s correction</span>
        <span class="c1"># to obtain the *unbiased sample variance* before taking the square root!</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">running_sum</span> <span class="o">/</span> <span class="n">total_pixels</span>
        <span class="n">std</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="p">(</span><span class="n">running_squared_sum</span> <span class="o">/</span> <span class="p">(</span><span class="n">total_pixels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="o">-</span> <span class="p">(</span><span class="n">total_pixels</span> <span class="o">/</span> <span class="p">(</span><span class="n">total_pixels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">mean</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">mean</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">std</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, <code class="docutils literal notranslate"><span class="pre">save_checkpoint</span></code> does exactly what you’d think it does.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">save_checkpoint</span><span class="p">(</span>
        <span class="n">epoch</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
        <span class="n">optimizer</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Optimizer</span><span class="p">,</span>
        <span class="n">scheduler</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">lr_scheduler</span><span class="o">.</span><span class="n">_LRScheduler</span><span class="p">,</span>
        <span class="n">train_logs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span>
        <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Save checkpoint during training.</span>

<span class="sd">    Args:</span>
<span class="sd">        epoch (int): The current epoch number.</span>
<span class="sd">        model (torch.nn.Module): The model to be saved.</span>
<span class="sd">        optimizer (torch.optim.Optimizer): The optimizer used to update the model&#39;s weights.</span>
<span class="sd">        scheduler (torch.optim.lr_scheduler._LRScheduler): The learning rate scheduler.</span>
<span class="sd">        train_logs (dict[str, list[float]]): A dictionary containing training logs.</span>
<span class="sd">        file_name (str): The file path where the checkpoint will be saved.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">({</span>
        <span class="s1">&#39;epoch&#39;</span><span class="p">:</span> <span class="n">epoch</span><span class="p">,</span>
        <span class="s1">&#39;model_state_dict&#39;</span><span class="p">:</span> <span class="n">model</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span>
        <span class="s1">&#39;optimizer_state_dict&#39;</span><span class="p">:</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span>
        <span class="s1">&#39;scheduler_state_dict&#39;</span><span class="p">:</span> <span class="n">scheduler</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span>
        <span class="s1">&#39;train_logs&#39;</span><span class="p">:</span> <span class="n">train_logs</span>
        <span class="p">},</span> <span class="n">file_name</span>
        <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="learning-rate-schedule-rex">
<h3>Learning Rate Schedule REX<a class="headerlink" href="#learning-rate-schedule-rex" title="Link to this heading">#</a></h3>
<p>In a deep learning project, we often want to start with a larger learning rate at the beginning stages of training and then decrease the learning rate over time to fine-tune the model under training. This is where learning rate schedulers come in handy. There are already many learning rate schedulers implemented in PyTorch as part of the <code class="docutils literal notranslate"><span class="pre">torch.optim</span></code> package (see <a class="reference external" href="https://pytorch.org/docs/stable/optim.html#how-to-adjust-learning-rate">here</a>). Here, we implement a learning rate scheduler that’s not readily available from the <code class="docutils literal notranslate"><span class="pre">torch.optim</span></code> package. The LR scheduler we will implement is based on an <a class="reference external" href="https://arxiv.org/pdf/2107.04197.pdf">article</a> by <em>John Chen</em>, <em>Cameron Wolfe</em>, and <em>Anastasios Kyrillidis</em> and is called <strong>REX</strong> (short for <em>Reflected Exponential</em>). In their paper, the authors claim that their REX schedule performs well across a variety of experimental settings and for varying numbers of training epochs. Hence, we decided to give this schedule a shot, which is given by</p>
<div class="math notranslate nohighlight">
\[
\eta_t^{[\text{REX}]} = \eta_0 \cdot \left(\frac{1 - \frac{t}{T}}{\frac{1}{2} + \frac{1}{2} \cdot (1 - \frac{t}{T})}\right)\,,
\]</div>
<p>where <span class="math notranslate nohighlight">\(t\)</span> denotes the current time step and <span class="math notranslate nohighlight">\(T\)</span> is the maximum time step. <span class="math notranslate nohighlight">\(\eta_t\)</span> is the learning rate at time <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(\eta_0\)</span> is the initial learning rate that was selected to run the training. Taking a brief look at this schedule, it is easy to see that the numerator decreases from <span class="math notranslate nohighlight">\(1\)</span> to <span class="math notranslate nohighlight">\(0\)</span> while the denominator simultaneously decreases from <span class="math notranslate nohighlight">\(1\)</span> to <span class="math notranslate nohighlight">\(0.5\)</span>. Hence, we can already guess that the learning rate itself will also gradually decrease from <span class="math notranslate nohighlight">\(1\)</span> to <span class="math notranslate nohighlight">\(0\)</span> (the learning rate never increases since the numerator decreases twice as fast as the denominator). However, it does <em>not</em> do so in a linear fashion. To see this, we can rewrite the formula for <span class="math notranslate nohighlight">\(\eta_t^{[\text{REX}]}\)</span> as follows:</p>
<div class="math notranslate nohighlight">
\[
\eta_t^{[\text{REX}]} = \eta_0 \cdot \frac{2(T - t)}{2T - t}\, .
\]</div>
<p>Then, the quotient rule tells us that the derivative of <span class="math notranslate nohighlight">\(\eta_t^{[\text{REX}]}\)</span> with respect to the time step <span class="math notranslate nohighlight">\(t\)</span> is given by</p>
<div class="math notranslate nohighlight">
\[
\dot\eta_t^{[\text{REX}]} = \frac{\mathrm{d} \eta_t^{[\text{REX}]}}{\mathrm{d} t} = -\eta_0 \cdot \frac{2T}{(2T - t)^2}\,,
\]</div>
<p>which is a <em>non-linear</em> function of <span class="math notranslate nohighlight">\(t\)</span>. To get a better understanding of the REX schedule, let’s visualize the learning rate <span class="math notranslate nohighlight">\(\eta_t^{[\text{REX}]}\)</span> as well as its derivative <span class="math notranslate nohighlight">\(\dot\eta_t^{[\text{REX}]}\)</span> and compare it to the <strong>linear decay</strong> scheme, which is given by</p>
<div class="math notranslate nohighlight">
\[
\eta_t = \eta_0 \cdot \left(1 - \frac{t}{T}\right)
\]</div>
<p>with (constant) derivative</p>
<div class="math notranslate nohighlight">
\[
\dot\eta_t = \frac{\mathrm{d} \eta_t}{\mathrm{d} t} = -\frac{\eta_0}{T}\,.
\]</div>
<p>By solving</p>
<div class="math notranslate nohighlight">
\[
-\eta_0 \cdot \frac{2T}{(2T - t)^2} = -\frac{\eta_0}{T},
\]</div>
<p>we see that (assuming identical initial learning rates <span class="math notranslate nohighlight">\(\eta_0\)</span>) the derivatives of the two learning rate schedules are equal for <span class="math notranslate nohighlight">\(t = (2 - \sqrt{2})\,T \approx 0.5858\,T\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">visualize_rex</span><span class="p">(</span>
        <span class="n">num_epochs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">save_plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Visualize the REX and linear decay learning rate schedules.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_epochs (int): The number of epochs of training.</span>
<span class="sd">        save_plot (bool, optional): Whether to save the generated plot.  Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">time_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_epochs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">decay_REX</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_epochs</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">num_epochs</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">time_steps</span><span class="p">]</span>
    <span class="n">decay_linear</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span> <span class="o">/</span> <span class="n">num_epochs</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">time_steps</span><span class="p">]</span>

    <span class="n">derivative_REX</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">num_epochs</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">num_epochs</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">time_steps</span><span class="p">]</span>
    <span class="n">derivative_linear</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="n">num_epochs</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_steps</span><span class="p">)</span>

    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
        <span class="n">linestyle</span> <span class="o">=</span> <span class="s1">&#39;solid&#39;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;dashed&#39;</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time_steps</span><span class="p">,</span> <span class="n">decay_REX</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">derivative_REX</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="n">linestyle</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time_steps</span><span class="p">,</span> <span class="n">decay_linear</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">derivative_linear</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="n">linestyle</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Epoch&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Decay Factors&#39;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;Derivatives&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;REX&#39;</span><span class="p">,</span> <span class="s1">&#39;Linear Decay&#39;</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;major&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#DDDDDD&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;minor&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#EEEEEE&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">minorticks_on</span><span class="p">()</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;REX Learning Rate Schedule&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">save_plot</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="s1">&#39;reports/figures/results/rex-schedule.png&#39;</span><span class="p">))</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s use this function straightaway to see how the two learning rate schedulers differ across epochs.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;reports/figures/results/rex-schedule.png&#39;</span><span class="p">)</span>
<span class="n">file_path</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">save_plot</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">file_path</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span> <span class="k">else</span> <span class="kc">False</span>

<span class="c1"># NOTE: The number of epochs qualitatively does not make any difference here</span>
<span class="n">visualize_rex</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">save_plot</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/dd371178e74e06c0bbca3c818b785657169683745c41dcab30bf5f5d847a6455.png" src="../../_images/dd371178e74e06c0bbca3c818b785657169683745c41dcab30bf5f5d847a6455.png" />
</div>
</div>
<p><strong>A note on the two plots</strong>: On the <em>left</em>, we have plotted the decay factors instead of the learning rates (i.e., <span class="math notranslate nohighlight">\(\eta_t/\eta_0\)</span> instead of <span class="math notranslate nohighlight">\(\eta_t\)</span>). On the <em>right</em>, we have plotted the derivatives (of the decay factors <span class="math notranslate nohighlight">\(\eta_t/\eta_0\)</span>) of the two schedules (i.e., REX and linear). This helps us better understand how the learning rate is adjusted in the REX schedule <em>compared to the linear decay schedule</em>.</p>
<p>We can see that, in the <em>REX</em> schedule, the learning rate is decreased less strongly in the earlier epochs and much more strongly in the later epochs compared to the <em>linear decay</em> schedule. <em>In theory</em>, this should allow our network to <em>learn more quickly</em> in the early stages of training while simultaneously keeping fluctuations in performance to a minimum at the later stages of training (as the learning rate is driven to <span class="math notranslate nohighlight">\(0\)</span> more aggressively toward the end than in the linear schedule).</p>
<p>Finally, let’s actually implement the <em>REX</em> learning rate scheduler.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ReflectedExponentialLR</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">lr_scheduler</span><span class="o">.</span><span class="n">LRScheduler</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implements a learning rate scheduler that uses a reflected exponential decay.</span>

<span class="sd">    This scheduler computes a learning rate factor based on a reflected exponential decay schedule</span>
<span class="sd">    and adjusts the learning rates for each parameter group accordingly.</span>

<span class="sd">    Args:</span>
<span class="sd">        optimizer (torch.optim.Optimizer): The optimizer used to update the model&#39;s weights.</span>
<span class="sd">        num_epochs (int): The number of epochs to train.</span>
<span class="sd">        last_epoch (int): The index of the last epoch.  Defaults to -1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Optimizer</span><span class="p">,</span>
            <span class="n">num_epochs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
            <span class="n">last_epoch</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span> <span class="o">=</span> <span class="n">num_epochs</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">last_epoch</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">get_lr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lr_called_within_step</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;To get the last learning rate computed by the scheduler, &quot;</span>
                          <span class="s2">&quot;please use `get_last_lr()`.&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>

        <span class="n">decay_factor</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_epoch</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_epoch</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">base_lr</span> <span class="o">*</span> <span class="n">decay_factor</span> <span class="k">for</span> <span class="n">base_lr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_lrs</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="training-and-testing-routines">
<h3>Training and Testing Routines<a class="headerlink" href="#training-and-testing-routines" title="Link to this heading">#</a></h3>
<p>In this section, we collect all the functions that allow us to train, validate, and test a model. First, we implement a simple function that <strong>runs a single epoch</strong>. It returns the average loss and the average accuracy across the epoch as a tuple of floats.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run_epoch</span><span class="p">(</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
        <span class="n">dataloader</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">,</span>
        <span class="n">loss_fn</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">loss</span><span class="o">.</span><span class="n">_Loss</span><span class="p">,</span>
        <span class="n">optimizer</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Optimizer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Run a single epoch using the provided dataloader, loss_fn, and optimizer.</span>

<span class="sd">    Args:</span>
<span class="sd">        model (torch.nn.Module): The model to be trained/evaluated.</span>
<span class="sd">        dataloader (torch.utils.data.DataLoader): A dataloader providing samples.</span>
<span class="sd">        loss_fn (torch.nn.modules.loss._Loss): The loss function used for evaluation.</span>
<span class="sd">        optimizer (torch.optim.Optimizer): The optimizer used to update the model&#39;s weights.</span>
<span class="sd">            Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[float, float]: A tuple containing the average loss and accuracy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set training/evaluation mode</span>
    <span class="n">is_training</span> <span class="o">=</span> <span class="n">optimizer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">is_training</span><span class="p">)</span>

    <span class="c1"># Initialize running totals</span>
    <span class="n">running_samples</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">running_loss</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">running_acc</span> <span class="o">=</span> <span class="mf">0.</span>

    <span class="k">with</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">set_grad_enabled</span><span class="p">(</span><span class="n">is_training</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">labels</span> <span class="ow">in</span> <span class="n">dataloader</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">DEVICE</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">DEVICE</span><span class="p">)</span>

            <span class="c1"># Keep track of the number of samples</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
            <span class="n">running_samples</span> <span class="o">+=</span> <span class="n">samples</span>

            <span class="c1"># Forward pass</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>

            <span class="c1"># Accumulate loss</span>
            <span class="n">running_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">*</span> <span class="n">samples</span>

            <span class="c1"># Compute accuracy</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="n">accuracy</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
            <span class="n">running_acc</span> <span class="o">+=</span> <span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">*</span> <span class="n">samples</span>

            <span class="c1"># Backward pass and optimization</span>
            <span class="k">if</span> <span class="n">is_training</span><span class="p">:</span>
                <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>  <span class="c1"># zero gradients</span>
                <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>        <span class="c1"># compute gradients</span>
                <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>       <span class="c1"># update weights</span>
            
    <span class="c1"># Compute average loss and accuracy over epoch</span>
    <span class="n">avg_loss</span> <span class="o">=</span> <span class="n">running_loss</span> <span class="o">/</span> <span class="n">running_samples</span>
    <span class="n">avg_acc</span> <span class="o">=</span> <span class="n">running_acc</span> <span class="o">/</span> <span class="n">running_samples</span>

    <span class="k">return</span> <span class="n">avg_loss</span><span class="p">,</span> <span class="n">avg_acc</span>
</pre></div>
</div>
</div>
</div>
<p>When we train a network, we usually train it for many epochs, where we <strong>iteratively train it on the training set, validate it using the validation set, and repeat</strong>. The next function does just that. Additionally, we implement the possibility to …</p>
<ul class="simple">
<li><p><strong>resume training</strong> by passing (the path to) a previously saved checkpoint to the function,</p></li>
<li><p>specify the frequency at which <strong>information</strong> about the training progress is <strong>printed to the console</strong>,</p></li>
<li><p>specify the frequency at which <strong>checkpoints</strong> are being saved (if at all).</p></li>
</ul>
<p><strong>Note</strong>: All of the checkpoints of training different models will be saved in the directory <code class="docutils literal notranslate"><span class="pre">models/</span></code> (relative to this notebook).</p>
<p>Now, let’s get to the <code class="docutils literal notranslate"><span class="pre">train</span></code> function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">train</span><span class="p">(</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
        <span class="n">train_loader</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">,</span>
        <span class="n">val_loader</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">,</span>
        <span class="n">loss_fn</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">loss</span><span class="o">.</span><span class="n">_Loss</span><span class="p">,</span>
        <span class="n">num_epochs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">checkpoint_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">print_freq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">save_freq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">checkpoint_dir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Train a model for the specified number of epochs using the provided dataloaders, loss function, and optimizer.</span>

<span class="sd">    Args:</span>
<span class="sd">        model (torch.nn.Module): The model to be trained.</span>
<span class="sd">        train_loader (torch.utils.data.DataLoader): A dataloader providing training samples.</span>
<span class="sd">        val_loader (torch.utils.data.DataLoader): A dataloader providing validation samples.</span>
<span class="sd">        loss_fn (torch.nn.modules.loss._Loss): The loss function used for evaluation.</span>
<span class="sd">        num_epochs (int): The number of epochs to train.</span>
<span class="sd">        checkpoint_path (str): Path to the checkpoint from which to resume training.  Defaults to None.</span>
<span class="sd">        print_freq (int): Frequency (in number of epochs) at which to print information about</span>
<span class="sd">            the training progress.  Defaults to None.</span>
<span class="sd">        save_freq (int): Frequency (in number of epochs) at which to save checkpoints of the training progress.</span>
<span class="sd">            Defaults to None.  In this case, no checkpoints are saved.</span>
<span class="sd">        checkpoint_dir (str): The name of the subdirectory in which to save checkpoints.  Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict[str, list[float]]: A dictionary containing training logs.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If &#39;save_freq&#39; is not &#39;None&#39; and &#39;checkpoint_dir&#39; is not a valid directory.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">save_freq</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">checkpoint_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Valid checkpoint directory must be provided when &#39;save_freq&#39; is not None.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Path</span><span class="p">(</span><span class="n">MODELS_DIR</span><span class="p">,</span> <span class="n">checkpoint_dir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Resume training if the path to a saved checkpoint is passed</span>
    <span class="k">if</span> <span class="n">checkpoint_path</span><span class="p">:</span>
        <span class="c1"># Load checkpoint</span>
        <span class="n">checkpoint</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">checkpoint_path</span><span class="p">,</span> <span class="n">map_location</span><span class="o">=</span><span class="n">DEVICE</span><span class="p">)</span>

        <span class="c1"># Load previous training logs</span>
        <span class="n">init_epoch</span> <span class="o">=</span> <span class="n">checkpoint</span><span class="p">[</span><span class="s1">&#39;epoch&#39;</span><span class="p">]</span>
        <span class="n">train_logs</span> <span class="o">=</span> <span class="n">checkpoint</span><span class="p">[</span><span class="s1">&#39;train_logs&#39;</span><span class="p">]</span>
        <span class="n">best_acc</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">train_logs</span><span class="p">[</span><span class="s1">&#39;val_acc&#39;</span><span class="p">])</span>

        <span class="c1"># Load model&#39;s state_dict</span>
        <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">[</span><span class="s1">&#39;model_state_dict&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Initialize training logs</span>
        <span class="n">init_epoch</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">train_logs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;train_loss&#39;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s1">&#39;train_acc&#39;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s1">&#39;val_loss&#39;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s1">&#39;val_acc&#39;</span><span class="p">:</span> <span class="p">[]</span>
            <span class="p">}</span>
        <span class="n">best_acc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Move model to target device</span>
    <span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">DEVICE</span><span class="p">)</span>

    <span class="c1"># Set up optimizer and scheduler</span>
    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span>
        <span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span>
        <span class="n">lr</span><span class="o">=</span><span class="n">LR</span><span class="p">,</span>
        <span class="n">momentum</span><span class="o">=</span><span class="n">MOMENTUM</span><span class="p">,</span>
        <span class="n">weight_decay</span><span class="o">=</span><span class="n">WEIGHT_DECAY</span>
        <span class="p">)</span>
    <span class="n">scheduler</span> <span class="o">=</span> <span class="n">ReflectedExponentialLR</span><span class="p">(</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">NUM_EPOCHS</span><span class="p">)</span>

    <span class="c1"># Load optimizer&#39;s and scheduler&#39;s state_dicts if training is to be resumed</span>
    <span class="k">if</span> <span class="n">checkpoint_path</span><span class="p">:</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">[</span><span class="s1">&#39;optimizer_state_dict&#39;</span><span class="p">])</span>
        <span class="n">scheduler</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">[</span><span class="s1">&#39;scheduler_state_dict&#39;</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">print_freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">print_freq</span> <span class="o">=</span> <span class="n">num_epochs</span> <span class="o">//</span> <span class="mi">10</span>

    <span class="c1"># Iterate over epochs</span>
    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">init_epoch</span><span class="p">,</span> <span class="n">init_epoch</span> <span class="o">+</span> <span class="n">num_epochs</span><span class="p">):</span>
        <span class="n">train_loss</span><span class="p">,</span> <span class="n">train_acc</span> <span class="o">=</span> <span class="n">run_epoch</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">train_loader</span><span class="p">,</span> <span class="n">loss_fn</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">)</span>
        <span class="n">val_loss</span><span class="p">,</span> <span class="n">val_acc</span> <span class="o">=</span> <span class="n">run_epoch</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">val_loader</span><span class="p">,</span> <span class="n">loss_fn</span><span class="p">)</span>

        <span class="c1"># Update learning rate</span>
        <span class="n">scheduler</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>

        <span class="c1"># Collect logs</span>
        <span class="n">train_logs</span><span class="p">[</span><span class="s1">&#39;train_loss&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">train_loss</span><span class="p">)</span>
        <span class="n">train_logs</span><span class="p">[</span><span class="s1">&#39;train_acc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">train_acc</span><span class="p">)</span>
        <span class="n">train_logs</span><span class="p">[</span><span class="s1">&#39;val_loss&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val_loss</span><span class="p">)</span>
        <span class="n">train_logs</span><span class="p">[</span><span class="s1">&#39;val_acc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val_acc</span><span class="p">)</span>

        <span class="c1"># Regularly print training progress to console</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">print_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Epoch [</span><span class="si">{:03d}</span><span class="s1">/</span><span class="si">{:03d}</span><span class="s1">]   Train   Loss=</span><span class="si">{:.4f}</span><span class="s1">   Acc=</span><span class="si">{:.2f}</span><span class="s1">    Val   Loss=</span><span class="si">{:.4f}</span><span class="s1">   Acc=</span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>                <span class="c1"># epoch number</span>
                <span class="n">init_epoch</span> <span class="o">+</span> <span class="n">num_epochs</span><span class="p">,</span>  <span class="c1"># total number of epochs</span>
                <span class="n">train_loss</span><span class="p">,</span>               <span class="c1"># loss (training)</span>
                <span class="n">train_acc</span><span class="p">,</span>                <span class="c1"># accuracy (training)</span>
                <span class="n">val_loss</span><span class="p">,</span>                 <span class="c1"># loss (validation)</span>
                <span class="n">val_acc</span>                   <span class="c1"># accuracy (validation)</span>
                <span class="p">))</span>

        <span class="c1"># Regularly save checkpoints</span>
        <span class="k">if</span> <span class="n">save_freq</span> <span class="ow">and</span> <span class="p">(</span><span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">save_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="n">MODELS_DIR</span> <span class="o">/</span> <span class="n">checkpoint_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s1">&#39;epoch-</span><span class="si">{</span><span class="n">epoch</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">:</span><span class="s1">03d</span><span class="si">}</span><span class="s1">_acc-</span><span class="si">{</span><span class="n">val_acc</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">.pt&#39;</span>
            <span class="n">save_checkpoint</span><span class="p">(</span>
                <span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">model</span><span class="p">,</span>
                <span class="n">optimizer</span><span class="p">,</span>
                <span class="n">scheduler</span><span class="p">,</span>
                <span class="n">train_logs</span><span class="p">,</span>
                <span class="n">file_name</span>
                <span class="p">)</span>

        <span class="c1"># Save additional checkpoint for best-performing model (highest accuracy on validation set)</span>
        <span class="k">if</span> <span class="n">checkpoint_dir</span> <span class="ow">and</span> <span class="n">val_acc</span> <span class="o">&gt;</span> <span class="n">best_acc</span><span class="p">:</span>
            <span class="n">best_acc</span> <span class="o">=</span> <span class="n">val_acc</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="n">MODELS_DIR</span> <span class="o">/</span> <span class="n">checkpoint_dir</span> <span class="o">/</span> <span class="s1">&#39;best_performing.pt&#39;</span>
            <span class="n">save_checkpoint</span><span class="p">(</span><span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">scheduler</span><span class="p">,</span> <span class="n">train_logs</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">train_logs</span>
</pre></div>
</div>
</div>
</div>
<p>Once we have successfully trained a model, we want to <strong>test its performance on a testing set</strong> that the model has never seen before.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test</span><span class="p">(</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
        <span class="n">test_loader</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">,</span>
        <span class="n">loss_fn</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">loss</span><span class="o">.</span><span class="n">_Loss</span><span class="p">,</span>
        <span class="n">print_results</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="nb">int</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Evaluate a model on a test set using the provided dataloader and loss_fn.</span>

<span class="sd">    Args:</span>
<span class="sd">        model (torch.nn.Module): The model to be tested.</span>
<span class="sd">        test_loader (torch.utils.data.DataLoader): A dataloader providing test samples.</span>
<span class="sd">        loss_fn (torch.nn.modules.loss._Loss): The loss function used for evaluation.</span>
<span class="sd">        print_results (bool): Specifies whether results are to be printed.  Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict (dict[str, float | int | dict[str, list[torch.Tensor | int]]]): A dictionary containing the average test</span>
<span class="sd">        loss, test accuracy, total samples, number of errors, and the misclassified images and labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set evaluation mode</span>
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>

    <span class="c1"># Initialize running totals</span>
    <span class="n">running_samples</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">running_loss</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">running_acc</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">running_errors</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Initialize dictionary to store info about misclassified samples</span>
    <span class="n">misclassified</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;images&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;labels&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;predicted_labels&#39;</span><span class="p">:</span> <span class="p">[]</span>
        <span class="p">}</span>
    
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">labels</span> <span class="ow">in</span> <span class="n">test_loader</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">DEVICE</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">DEVICE</span><span class="p">)</span>

            <span class="c1"># Keep track of the number of samples</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
            <span class="n">running_samples</span> <span class="o">+=</span> <span class="n">samples</span>

            <span class="c1"># Forward pass</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>

            <span class="c1"># Accumulate loss</span>
            <span class="n">running_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">*</span> <span class="n">samples</span>

            <span class="c1"># Compute accuracy</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="n">accuracy</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
            <span class="n">running_acc</span> <span class="o">+=</span> <span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">*</span> <span class="n">samples</span>

            <span class="c1"># Determine misclassified samples</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">predicted_labels</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">errors</span> <span class="o">=</span> <span class="n">predicted_labels</span> <span class="o">!=</span> <span class="n">labels</span>
            <span class="n">running_errors</span> <span class="o">+=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            
            <span class="c1"># Keep track of misclassified samples</span>
            <span class="n">misclassified</span><span class="p">[</span><span class="s1">&#39;images&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="n">errors</span><span class="p">])</span>
            <span class="n">misclassified</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">errors</span><span class="p">])</span>
            <span class="n">misclassified</span><span class="p">[</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">predicted_labels</span><span class="p">[</span><span class="n">errors</span><span class="p">])</span>

    <span class="n">test_loss</span> <span class="o">=</span> <span class="n">running_loss</span> <span class="o">/</span> <span class="n">running_samples</span>
    <span class="n">test_acc</span> <span class="o">=</span> <span class="n">running_acc</span> <span class="o">/</span> <span class="n">running_samples</span>

    <span class="k">if</span> <span class="n">print_results</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Test Results   Loss=</span><span class="si">{:.4f}</span><span class="s1">   Acc=</span><span class="si">{:.2f}</span><span class="s1">   Samples correct: </span><span class="si">{:d}</span><span class="s1">/</span><span class="si">{:d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">test_loss</span><span class="p">,</span>                         <span class="c1"># loss</span>
            <span class="n">test_acc</span><span class="p">,</span>                          <span class="c1"># accuracy</span>
            <span class="n">running_samples</span> <span class="o">-</span> <span class="n">running_errors</span><span class="p">,</span>  <span class="c1"># correctly classified</span>
            <span class="n">running_samples</span>                    <span class="c1"># total number of samples in the testing set</span>
            <span class="p">))</span>

    <span class="n">test_results</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;test_loss&#39;</span><span class="p">:</span> <span class="n">test_loss</span><span class="p">,</span>
        <span class="s1">&#39;test_acc&#39;</span><span class="p">:</span> <span class="n">test_acc</span><span class="p">,</span>
        <span class="s1">&#39;total_samples&#39;</span><span class="p">:</span> <span class="n">running_samples</span><span class="p">,</span>
        <span class="s1">&#39;num_errors&#39;</span><span class="p">:</span> <span class="n">running_errors</span><span class="p">,</span>
        <span class="s1">&#39;misclassified&#39;</span><span class="p">:</span> <span class="n">misclassified</span>
        <span class="p">}</span>

    <span class="k">return</span> <span class="n">test_results</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, we define a function that lets us train a model on a single batch of inputs and labels. This will allow us to <strong>overfit any model on a single batch</strong>, which is a useful debugging method that’s often used to make sure that the overall training pipeline is free of any major bugs.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">train_on_single_batch</span><span class="p">(</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">loss_fn</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">loss</span><span class="o">.</span><span class="n">_Loss</span><span class="p">,</span>
        <span class="n">num_epochs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">print_freq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Train a model for the specified number of epochs on a single batch of samples.</span>

<span class="sd">    Args:</span>
<span class="sd">        model (torch.nn.Module): The model to be trained.</span>
<span class="sd">        inputs (torch.Tensor): The single batch of inputs for training.</span>
<span class="sd">        labels (torch.Tensor): The single batch of labels for training.</span>
<span class="sd">        loss_fn (torch.nn.modules.loss._Loss): The loss function used for evaluation.</span>
<span class="sd">        num_epochs (int): The number of epochs to train.</span>
<span class="sd">        print_freq (int): Frequency (in number of epochs) at which to print information about the training progress.</span>
<span class="sd">            Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict (dict[str, list[float]]): A dictionary containing training logs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set training mode</span>
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>

    <span class="c1"># Move model to target device</span>
    <span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">DEVICE</span><span class="p">)</span>

    <span class="c1"># Set up optimizer</span>
    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span>
        <span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span>
        <span class="n">lr</span><span class="o">=</span><span class="n">LR</span><span class="p">,</span>
        <span class="n">momentum</span><span class="o">=</span><span class="n">MOMENTUM</span><span class="p">,</span>
        <span class="n">weight_decay</span><span class="o">=</span><span class="n">WEIGHT_DECAY</span>
        <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">print_freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">print_freq</span> <span class="o">=</span> <span class="n">num_epochs</span> <span class="o">//</span> <span class="mi">10</span>

    <span class="c1"># Initialize training logs</span>
    <span class="n">train_logs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;train_loss&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;train_acc&#39;</span><span class="p">:</span> <span class="p">[]</span>
        <span class="p">}</span>

    <span class="n">inputs</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">DEVICE</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">DEVICE</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_epochs</span><span class="p">):</span>
        <span class="c1"># Forward pass</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>

        <span class="c1"># Compute accuracy</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="n">accuracy</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>

        <span class="c1"># Backward pass and optimization</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>  <span class="c1"># zero gradients</span>
        <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>        <span class="c1"># compute gradients</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>       <span class="c1"># update weights</span>

        <span class="c1"># Collect logs</span>
        <span class="n">train_logs</span><span class="p">[</span><span class="s1">&#39;train_loss&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
        <span class="n">train_logs</span><span class="p">[</span><span class="s1">&#39;train_acc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">print_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Epoch [</span><span class="si">{:03d}</span><span class="s1">/</span><span class="si">{:03d}</span><span class="s1">]   Loss=</span><span class="si">{:.4f}</span><span class="s1">   Acc=</span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>     <span class="c1"># epoch number</span>
                <span class="n">num_epochs</span><span class="p">,</span>    <span class="c1"># total number of epochs</span>
                <span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>   <span class="c1"># loss</span>
                <span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>  <span class="c1"># accuracy</span>
            <span class="p">))</span>

    <span class="k">return</span> <span class="n">train_logs</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="transforming-and-augmenting-images">
<h3>Transforming and Augmenting Images<a class="headerlink" href="#transforming-and-augmenting-images" title="Link to this heading">#</a></h3>
<p>As mentioned before, there are <span class="math notranslate nohighlight">\(57\)</span> different cards in a standard <em>Dobble</em> deck (for an unknown reason, there are only <span class="math notranslate nohighlight">\(55\)</span> playing cards in the retailed version). This gives us <span class="math notranslate nohighlight">\((57 \times 56) / 2 = 1,596\)</span> different pairs of cards, which is the size of the full dataset that we’ll be working with. If we split this dataset into training, validation, and testing sets using ratios of <span class="math notranslate nohighlight">\(70\%\)</span>, <span class="math notranslate nohighlight">\(15\%\)</span>, and <span class="math notranslate nohighlight">\(15\%\)</span>, respectively, we end up with a training set consisting of <span class="math notranslate nohighlight">\(1117\)</span> images. We are already increasing the variability in our training data a bit by randomly assigning a position to each playing card in every epoch. Here, we want to improve the variability in our training data a bit further, by introducing image augmentation techniques.</p>
<p>However, before we do so, let’s take care of the normalization of our data first. Since the images that we’ll be using differ quite drastically from natural images, we will <em>not</em> be using the mean and standard deviation of common image databases such as <a class="reference external" href="https://www.image-net.org/index.php">ImageNet</a>. Instead, we use our <code class="docutils literal notranslate"><span class="pre">compute_mean_std</span></code> function to compute the mean and standard deviation of our data. We will do this as follows: Since the background color of each tile image is randomly chosen to be an arbitrary color (sampled from a uniform distribution), the average background color will be gray with a brightness of <span class="math notranslate nohighlight">\(50\%\)</span> (if we sample often enough). Hence, we can compute the mean and standard deviation of the datasets that we’ll be working with as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># full_set_gray_bg = DobbleDataset(</span>
<span class="c1">#     pairs_csv, bg_color=(127, 127, 127),</span>
<span class="c1">#     preprocess=transforms.Compose([</span>
<span class="c1">#         transforms.ToImage(),</span>
<span class="c1">#         transforms.ToDtype(torch.float32, scale=True)</span>
<span class="c1">#         ]))</span>

<span class="c1"># BATCH_SIZE = 16</span>
<span class="c1"># full_set_gray_bg_loader = torch.utils.data.DataLoader(</span>
<span class="c1">#     full_set_gray_bg, batch_size=BATCH_SIZE</span>
<span class="c1">#     )</span>

<span class="c1"># MEAN, STD = calculate_mean_std(full_set_gray_bg_loader)</span>

<span class="c1"># MEAN = [round(val, 4) for val in MEAN]</span>
<span class="c1"># STD = [round(val, 4) for val in STD]</span>

<span class="c1"># print(f&#39;MEAN: {MEAN}&#39;)</span>
<span class="c1"># print(f&#39;STD: {STD}&#39;)</span>
</pre></div>
</div>
</div>
</div>
<p><strong>Note</strong>: Since the computation can be a bit time-consuming (depending on your setup), we have commented it out and simply hard-coded the values that we obtained from the computation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">MEAN</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.6433</span><span class="p">,</span> <span class="mf">0.635</span><span class="p">,</span> <span class="mf">0.6188</span><span class="p">]</span>
<span class="n">STD</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.2535</span><span class="p">,</span> <span class="mf">0.2543</span><span class="p">,</span> <span class="mf">0.2659</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>With these values at hand, we can define our <strong>preprocessing transform</strong> already.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">preprocess</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span>
    <span class="n">transforms</span><span class="o">.</span><span class="n">Resize</span><span class="p">((</span><span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">)),</span>
    <span class="n">transforms</span><span class="o">.</span><span class="n">ToImage</span><span class="p">(),</span>
    <span class="n">transforms</span><span class="o">.</span><span class="n">ToDtype</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">transforms</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">MEAN</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="n">STD</span><span class="p">)</span>
    <span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>Later on, we will also be working with <strong>ResNet</strong> architectures of different depths. These require their own preprocessing as specified <a class="reference external" href="https://pytorch.org/vision/main/models/generated/torchvision.models.resnet18.html#torchvision.models.resnet18">here</a>.</p>
<p><strong>Note</strong>: In PyTorch, <a class="reference external" href="https://pytorch.org/vision/main/models/resnet.html">ResNet architectures</a> are available with those depths that were introduced in the original paper <a class="reference external" href="https://arxiv.org/pdf/1512.03385.pdf">Deep residual learning for image recognition</a>, i.e., 18, 34, 50, 101, and 152. The following <strong>pre-trained weights</strong> are available:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">IMAGENET1K_V1</span></code>: Available for all ResNet models</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IMAGENET1K_V2</span></code>: Available for all ResNet models <em>except</em> ResNet18 and ResNet34</p></li>
</ul>
<p>Depending on the pre-trained models that are used (if any), the preprocessing differs in the first resizing step. We will <strong>implement</strong> the correct <strong>preprocessing pipelines for both sets of pre-trained weights</strong> (i.e., V1 and V2).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">preprocess_imagenet1k_v1</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span>
    <span class="n">transforms</span><span class="o">.</span><span class="n">Resize</span><span class="p">(</span><span class="mi">256</span><span class="p">),</span>
    <span class="n">transforms</span><span class="o">.</span><span class="n">CenterCrop</span><span class="p">(</span><span class="mi">224</span><span class="p">),</span>
    <span class="n">transforms</span><span class="o">.</span><span class="n">ToImage</span><span class="p">(),</span>
    <span class="n">transforms</span><span class="o">.</span><span class="n">ToDtype</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">transforms</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span>
        <span class="n">mean</span><span class="o">=</span><span class="p">[</span><span class="mf">0.485</span><span class="p">,</span> <span class="mf">0.456</span><span class="p">,</span> <span class="mf">0.406</span><span class="p">],</span>
        <span class="n">std</span><span class="o">=</span><span class="p">[</span><span class="mf">0.229</span><span class="p">,</span> <span class="mf">0.224</span><span class="p">,</span> <span class="mf">0.225</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="p">])</span>

<span class="n">preprocess_imagenet1k_v2</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span>
    <span class="n">transforms</span><span class="o">.</span><span class="n">Resize</span><span class="p">(</span><span class="mi">232</span><span class="p">),</span>  <span class="c1"># only difference</span>
    <span class="n">transforms</span><span class="o">.</span><span class="n">CenterCrop</span><span class="p">(</span><span class="mi">224</span><span class="p">),</span>
    <span class="n">transforms</span><span class="o">.</span><span class="n">ToImage</span><span class="p">(),</span>
    <span class="n">transforms</span><span class="o">.</span><span class="n">ToDtype</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">transforms</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span>
        <span class="n">mean</span><span class="o">=</span><span class="p">[</span><span class="mf">0.485</span><span class="p">,</span> <span class="mf">0.456</span><span class="p">,</span> <span class="mf">0.406</span><span class="p">],</span>
        <span class="n">std</span><span class="o">=</span><span class="p">[</span><span class="mf">0.229</span><span class="p">,</span> <span class="mf">0.224</span><span class="p">,</span> <span class="mf">0.225</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>With the preprocessing out of the way, we now turn to image augmentation. First, we implement a series of augmentations that we apply to the <strong>images of the individual playing cards</strong>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">individual_transform</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">RandomApply</span><span class="p">([</span>
    <span class="n">transforms</span><span class="o">.</span><span class="n">RandomHorizontalFlip</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">),</span>
    <span class="n">transforms</span><span class="o">.</span><span class="n">RandomPerspective</span><span class="p">(</span><span class="n">distortion_scale</span><span class="o">=</span><span class="mf">0.4</span><span class="p">),</span>
    <span class="n">transforms</span><span class="o">.</span><span class="n">RandomAffine</span><span class="p">(</span>
        <span class="n">degrees</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">180</span><span class="p">),</span>
        <span class="n">translate</span><span class="o">=</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">),</span>
        <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">],</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.75</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Additionally, we will also apply a simple augmentation to the <strong>tile images of pairs of cards</strong>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tile_transform</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">ColorJitter</span><span class="p">(</span><span class="n">brightness</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">contrast</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s investigate the effects of these augmentations!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Again, we set some random seeds for reproducibility</span>
<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>        <span class="c1"># identical cards &amp; positioning</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>     <span class="c1"># identical background colors</span>
<span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># identical transforms</span>

<span class="n">full_set</span> <span class="o">=</span> <span class="n">DobbleDataset</span><span class="p">(</span>
    <span class="n">pairs_csv</span><span class="p">,</span>
    <span class="n">individual_transform</span><span class="o">=</span><span class="n">individual_transform</span><span class="p">,</span>
    <span class="n">tile_transform</span><span class="o">=</span><span class="n">tile_transform</span><span class="p">,</span>
    <span class="n">preprocess</span><span class="o">=</span><span class="n">preprocess</span>
    <span class="p">)</span>

<span class="n">BATCH_SIZE</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">NUM_WORKERS</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">full_loader</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span>
    <span class="n">full_set</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="n">BATCH_SIZE</span><span class="p">,</span>
    <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>

<span class="n">images</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">full_loader</span><span class="p">))</span>
<span class="n">images_np</span> <span class="o">=</span> <span class="n">images</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
<span class="n">images_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">images_np</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># (B, H, W, C)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;reports/figures/cards/image-augmentation.png&#39;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">images_np</span><span class="p">,</span> <span class="n">labels</span><span class="p">)):</span>
    <span class="c1"># Extract individual color channels</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Undo normalization</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">STD</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">MEAN</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">g</span> <span class="o">*</span> <span class="n">STD</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">MEAN</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">STD</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">MEAN</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># Recombine color channels and clip values to unit interval (necessary b/c of computational inaccuracies)</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">labels_dict</span><span class="p">[</span><span class="n">label</span><span class="o">.</span><span class="n">item</span><span class="p">()])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Augmented Images&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">file_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/257698257150fe12d29a32360138567466afdbc071cf52e488b800904bc1e890.png" src="../../_images/257698257150fe12d29a32360138567466afdbc071cf52e488b800904bc1e890.png" />
</div>
</div>
</section>
</section>
<section id="resnet-models-of-different-depths">
<h2>ResNet Models of Different Depths<a class="headerlink" href="#resnet-models-of-different-depths" title="Link to this heading">#</a></h2>
<p>In this section, we will train <em>ResNet</em> models of different depths (keeping all other parameters constant) to see if the depth itself has an impact on the model performance.</p>
<section id="parameters-and-preparation">
<h3>Parameters and Preparation<a class="headerlink" href="#parameters-and-preparation" title="Link to this heading">#</a></h3>
<p>First, let’s <strong>set the target device</strong> that we’ll be using for training purposes.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">DEVICE</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span>
    <span class="s1">&#39;cuda&#39;</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span>
    <span class="k">else</span> <span class="s1">&#39;mps&#39;</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">mps</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span>
    <span class="k">else</span> <span class="s1">&#39;cpu&#39;</span>
    <span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Target device: </span><span class="si">{</span><span class="n">DEVICE</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Target device: mps
</pre></div>
</div>
</div>
</div>
<p>Next, let’s set some (fixed) <strong>parameters</strong> that we’ll use during training.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">TRAIN_RATIO</span> <span class="o">=</span> <span class="mf">0.7</span>
<span class="n">VAL_RATIO</span> <span class="o">=</span> <span class="mf">0.15</span>

<span class="n">NUM_EPOCHS</span> <span class="o">=</span> <span class="mi">300</span>

<span class="n">BATCH_SIZE</span> <span class="o">=</span> <span class="mi">64</span>
<span class="n">NUM_WORKERS</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">LR</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">MOMENTUM</span> <span class="o">=</span> <span class="mf">0.9</span>
<span class="n">WEIGHT_DECAY</span> <span class="o">=</span> <span class="mf">1e-4</span>

<span class="n">LOSS_FN</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">CrossEntropyLoss</span><span class="p">()</span>
<span class="n">NUM_CLASSES</span> <span class="o">=</span> <span class="mi">57</span>

<span class="n">PRINT_FREQ</span> <span class="o">=</span> <span class="mi">25</span>
<span class="n">SAVE_FREQ</span> <span class="o">=</span> <span class="mi">50</span>

<span class="n">RANDOM_SEED</span> <span class="o">=</span> <span class="mi">42</span>
</pre></div>
</div>
</div>
</div>
<p>For each available depth (i.e., 18, 34, 50, 101, 152), we will have to <strong>create the corresponding ResNet model</strong> and replace the fully connected layer with one that has the appropriate size. Since this would lead to repetitive code, we write another little helper function that does this job for us.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_resnet_model</span><span class="p">(</span>
        <span class="n">num_classes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">weights</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">random_seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a ResNet model of specified depth and with a specified number of classes.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_classes (int): The number of output classes.</span>
<span class="sd">        depth (int): The depth of the ResNet model.  Supported depths are 18, 34, 50, 101, and 152.</span>
<span class="sd">        weights (str): If provided, the function loads pre-trained weights for the specified depth.</span>
<span class="sd">            Defaults to &#39;None&#39;, in which case the model will be randomly initialized.</span>
<span class="sd">        random_seed (int): If provided, the random seed will be used to initialize the model weights</span>
<span class="sd">            for reproducibility.  Defaults to &#39;None&#39;, in which case no random seed will be set.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.nn.Module: The created ResNet model with the desired fully connected layer.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If an invalid depth is provided. Supported depths are 18, 34, 50, 101, and 152.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">random_seed</span><span class="p">:</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>

    <span class="c1"># Create model with specified pre-trained (or randomly initialized) weights</span>
    <span class="n">available_depths</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">18</span><span class="p">:</span> <span class="n">models</span><span class="o">.</span><span class="n">resnet18</span><span class="p">,</span>
        <span class="mi">34</span><span class="p">:</span> <span class="n">models</span><span class="o">.</span><span class="n">resnet34</span><span class="p">,</span>
        <span class="mi">50</span><span class="p">:</span> <span class="n">models</span><span class="o">.</span><span class="n">resnet50</span><span class="p">,</span>
        <span class="mi">101</span><span class="p">:</span> <span class="n">models</span><span class="o">.</span><span class="n">resnet101</span><span class="p">,</span>
        <span class="mi">152</span><span class="p">:</span> <span class="n">models</span><span class="o">.</span><span class="n">resnet152</span>
        <span class="p">}</span>

    <span class="k">if</span> <span class="n">depth</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">available_depths</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid depth. Supported depths are 18, 34, 50, 101, and 152.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">available_depths</span><span class="p">[</span><span class="n">depth</span><span class="p">](</span><span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

    <span class="c1"># Replace fully connected layer</span>
    <span class="n">in_features</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fc</span><span class="o">.</span><span class="n">in_features</span>
    <span class="n">model</span><span class="o">.</span><span class="n">fc</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_features</span><span class="o">=</span><span class="n">in_features</span><span class="p">,</span> <span class="n">out_features</span><span class="o">=</span><span class="n">num_classes</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">model</span>
</pre></div>
</div>
</div>
</div>
<p>Also, the <strong>datasets and dataloaders</strong> that we will be using will remain the same. So let’s just create them right now.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">train_csv</span><span class="p">,</span> <span class="n">val_csv</span><span class="p">,</span> <span class="n">test_csv</span> <span class="o">=</span> <span class="n">split_dataset</span><span class="p">(</span><span class="n">pairs_csv</span><span class="p">,</span> <span class="n">TRAIN_RATIO</span><span class="p">,</span> <span class="n">VAL_RATIO</span><span class="p">)</span>

<span class="c1"># We&#39;ll use image augmentation for our training set ...</span>
<span class="n">train_set</span> <span class="o">=</span> <span class="n">DobbleDataset</span><span class="p">(</span>
    <span class="n">train_csv</span><span class="p">,</span>
    <span class="n">individual_transform</span><span class="o">=</span><span class="n">individual_transform</span><span class="p">,</span>
    <span class="n">tile_transform</span><span class="o">=</span><span class="n">tile_transform</span><span class="p">,</span>
    <span class="n">preprocess</span><span class="o">=</span><span class="n">preprocess</span>
    <span class="p">)</span>

<span class="c1"># ... but not for our validation or testing sets</span>
<span class="n">val_set</span> <span class="o">=</span> <span class="n">DobbleDataset</span><span class="p">(</span><span class="n">val_csv</span><span class="p">,</span> <span class="n">preprocess</span><span class="o">=</span><span class="n">preprocess</span><span class="p">)</span>
<span class="n">test_set</span> <span class="o">=</span> <span class="n">DobbleDataset</span><span class="p">(</span><span class="n">test_csv</span><span class="p">,</span> <span class="n">preprocess</span><span class="o">=</span><span class="n">preprocess</span><span class="p">)</span>

<span class="c1"># Create dataloaders</span>
<span class="n">train_loader</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span>
    <span class="n">train_set</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="n">BATCH_SIZE</span><span class="p">,</span>
    <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">num_workers</span><span class="o">=</span><span class="n">NUM_WORKERS</span>
    <span class="p">)</span>

<span class="n">val_loader</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span>
    <span class="n">val_set</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="n">BATCH_SIZE</span><span class="p">,</span>
    <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">num_workers</span><span class="o">=</span><span class="n">NUM_WORKERS</span>
    <span class="p">)</span>

<span class="n">test_loader</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span>
    <span class="n">test_set</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="n">BATCH_SIZE</span><span class="p">,</span>
    <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">num_workers</span><span class="o">=</span><span class="n">NUM_WORKERS</span>
    <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="resnet-18">
<h3>ResNet-18<a class="headerlink" href="#resnet-18" title="Link to this heading">#</a></h3>
<p>To make sure that our <code class="docutils literal notranslate"><span class="pre">train</span></code> function works as expected, we will first train Resnet-18 for 100 epochs, and then try to resume training and train it for another 200 epochs so that we have trained for a total of 300 epochs, as set by our argument <code class="docutils literal notranslate"><span class="pre">NUM_EPOCHS</span></code>. We also set random seeds so that we can reprodruce the exact training results later on. Besides calling <code class="docutils literal notranslate"><span class="pre">torch.manual_seed()</span></code>, we also have to set seeds for <code class="docutils literal notranslate"><span class="pre">random</span></code> and <code class="docutils literal notranslate"><span class="pre">numpy</span></code>. This is due to the fact that</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">random</span></code> is involved in determining the positions of playing cards when creating the tile images,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numpy</span></code> is used to randomly set the background color of the tile images.</p></li>
</ul>
<p>Not setting random seeds for these two packages would result in different training and validation samples because the samples (tile images) are generated on the fly by the dataloader created from the <code class="docutils literal notranslate"><span class="pre">DobbleDataset</span></code> class.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># # Instantiate ResNet-18 model</span>
<span class="c1"># resnet18 = create_resnet_model(NUM_CLASSES, depth=18, random_seed=RANDOM_SEED)</span>

<span class="c1"># # Random seeds for reproducibility of training results</span>
<span class="c1"># random.seed(RANDOM_SEED)</span>
<span class="c1"># np.random.seed(RANDOM_SEED)</span>
<span class="c1"># torch.manual_seed(RANDOM_SEED)</span>

<span class="c1"># # We deviate from &#39;NUM_EPOCHS&#39; to test our &#39;train&#39; function ...</span>
<span class="c1"># num_epochs = 100</span>

<span class="c1"># resnet18_train_logs = train(</span>
<span class="c1">#     resnet18,</span>
<span class="c1">#     train_loader,</span>
<span class="c1">#     val_loader,</span>
<span class="c1">#     LOSS_FN,</span>
<span class="c1">#     num_epochs,</span>
<span class="c1">#     print_freq=PRINT_FREQ,</span>
<span class="c1">#     save_freq=SAVE_FREQ,</span>
<span class="c1">#     checkpoint_dir=&#39;resnet18&#39;</span>
<span class="c1">#     )</span>

<span class="n">checkpoint</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
    <span class="s1">&#39;models/resnet18/epoch-100_acc-61.0879.pt&#39;</span><span class="p">,</span>
    <span class="n">map_location</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span>
    <span class="p">)</span>
<span class="n">train_logs</span> <span class="o">=</span> <span class="n">checkpoint</span><span class="p">[</span><span class="s1">&#39;train_logs&#39;</span><span class="p">]</span>
<span class="n">reprint_logs</span><span class="p">(</span><span class="n">train_logs</span><span class="p">,</span> <span class="n">print_freq</span><span class="o">=</span><span class="n">PRINT_FREQ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Epoch [025/100]   Train   Loss=3.8498   Acc=4.74    Val   Loss=4.1519   Acc=3.77
Epoch [050/100]   Train   Loss=2.8890   Acc=19.87    Val   Loss=6.1811   Acc=2.51
Epoch [075/100]   Train   Loss=1.5020   Acc=57.92    Val   Loss=3.6937   Acc=14.64
Epoch [100/100]   Train   Loss=0.4595   Acc=90.69    Val   Loss=1.1209   Acc=61.09
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># # ... and here we train the remaining 200 epochs!</span>
<span class="c1"># num_epochs = 200</span>

<span class="c1"># # Select the checkpoint that we saved earlier ...</span>
<span class="c1"># checkpoint_path = &#39;models/resnet18/epoch-100_acc-61.0879.pt&#39;</span>

<span class="c1"># # ... and resume the training progress.</span>
<span class="c1"># resnet18_train_logs = train(</span>
<span class="c1">#     resnet18,</span>
<span class="c1">#     train_loader,</span>
<span class="c1">#     val_loader,</span>
<span class="c1">#     LOSS_FN,</span>
<span class="c1">#     num_epochs,</span>
<span class="c1">#     checkpoint_path=checkpoint_path,</span>
<span class="c1">#     print_freq=PRINT_FREQ,</span>
<span class="c1">#     save_freq=SAVE_FREQ,</span>
<span class="c1">#     checkpoint_dir=&#39;resnet18&#39;</span>
<span class="c1">#     )</span>

<span class="n">checkpoint</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
    <span class="s1">&#39;models/resnet18/epoch-300_acc-99.5816.pt&#39;</span><span class="p">,</span>
    <span class="n">map_location</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span>
    <span class="p">)</span>
<span class="n">train_logs</span> <span class="o">=</span> <span class="n">checkpoint</span><span class="p">[</span><span class="s1">&#39;train_logs&#39;</span><span class="p">]</span>
<span class="n">reprint_logs</span><span class="p">(</span><span class="n">train_logs</span><span class="p">,</span> <span class="n">start_after</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">print_freq</span><span class="o">=</span><span class="n">PRINT_FREQ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Epoch [125/300]   Train   Loss=0.1309   Acc=99.10    Val   Loss=0.9341   Acc=72.38
Epoch [150/300]   Train   Loss=0.0662   Acc=99.91    Val   Loss=0.2203   Acc=97.49
Epoch [175/300]   Train   Loss=0.0429   Acc=99.82    Val   Loss=0.0954   Acc=99.58
Epoch [200/300]   Train   Loss=0.0356   Acc=100.00    Val   Loss=0.0937   Acc=100.00
Epoch [225/300]   Train   Loss=0.0280   Acc=100.00    Val   Loss=0.0476   Acc=100.00
Epoch [250/300]   Train   Loss=0.0235   Acc=100.00    Val   Loss=0.0482   Acc=99.58
Epoch [275/300]   Train   Loss=0.0198   Acc=100.00    Val   Loss=0.0380   Acc=100.00
Epoch [300/300]   Train   Loss=0.0182   Acc=100.00    Val   Loss=0.0388   Acc=99.58
</pre></div>
</div>
</div>
</div>
<p>Let’s take a look at the results!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">checkpoint</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
    <span class="s1">&#39;models/resnet18/epoch-300_acc-99.5816.pt&#39;</span><span class="p">,</span>
    <span class="n">map_location</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span>
    <span class="p">)</span>

<span class="n">figure_title</span> <span class="o">=</span> <span class="s1">&#39;resnet18-training.png&#39;</span>
<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;reports/figures/results&#39;</span><span class="p">,</span> <span class="n">figure_title</span><span class="p">)</span>
<span class="n">save_plot</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">file_path</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span>
<span class="n">plot_loss_and_accuracy</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">[</span><span class="s1">&#39;train_logs&#39;</span><span class="p">],</span> <span class="n">save_plot</span><span class="p">,</span> <span class="n">figure_title</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/caa0eb671e6569fe111ee7e73db33b95e4d669ed8f380f11cbc9c14625d65ff0.png" src="../../_images/caa0eb671e6569fe111ee7e73db33b95e4d669ed8f380f11cbc9c14625d65ff0.png" />
</div>
</div>
</section>
<section id="remaining-resnet-models">
<h3>Remaining ResNet Models<a class="headerlink" href="#remaining-resnet-models" title="Link to this heading">#</a></h3>
<p>Now, let’s systematically train the remaining ResNet models that are available in PyTorch.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># resnet_depths = [34, 50, 101, 152]</span>

<span class="c1"># for count, depth in enumerate(resnet_depths):</span>
<span class="c1">#     if count &gt; 0:</span>
<span class="c1">#         print(&#39;\n\n&#39;)</span>

<span class="c1">#     print(f&#39;CURRENTLY TRAINING: RESNET-{depth}\n&#39;)</span>

<span class="c1">#     resnet = create_resnet_model(NUM_CLASSES, depth=depth, random_seed=RANDOM_SEED)</span>

<span class="c1">#     # Random seeds for reproducibility of training results</span>
<span class="c1">#     random.seed(RANDOM_SEED)</span>
<span class="c1">#     np.random.seed(RANDOM_SEED)</span>
<span class="c1">#     torch.manual_seed(RANDOM_SEED)</span>

<span class="c1">#     _ = train(</span>
<span class="c1">#         resnet,</span>
<span class="c1">#         train_loader,</span>
<span class="c1">#         val_loader,</span>
<span class="c1">#         LOSS_FN,</span>
<span class="c1">#         NUM_EPOCHS,</span>
<span class="c1">#         print_freq=PRINT_FREQ,</span>
<span class="c1">#         save_freq=SAVE_FREQ,</span>
<span class="c1">#         checkpoint_dir=f&#39;resnet{depth}&#39;</span>
<span class="c1">#         )</span>

<span class="n">checkpoints</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">34</span><span class="p">:</span> <span class="s1">&#39;resnet34/epoch-300_acc-100.0000.pt&#39;</span><span class="p">,</span>
    <span class="mi">50</span><span class="p">:</span> <span class="s1">&#39;resnet50/epoch-300_acc-97.4895.pt&#39;</span><span class="p">,</span>
    <span class="mi">101</span><span class="p">:</span> <span class="s1">&#39;resnet101/epoch-300_acc-89.1213.pt&#39;</span><span class="p">,</span>
    <span class="mi">152</span><span class="p">:</span> <span class="s1">&#39;resnet152/epoch-300_acc-68.2008.pt&#39;</span>
    <span class="p">}</span>

<span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">checkpoint_path</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">checkpoints</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;CURRENTLY TRAINING: RESNET-</span><span class="si">{</span><span class="n">depth</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    
    <span class="n">checkpoint</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
        <span class="n">MODELS_DIR</span> <span class="o">/</span> <span class="n">checkpoint_path</span><span class="p">,</span>
        <span class="n">map_location</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span>
        <span class="p">)</span>
    <span class="n">train_logs</span> <span class="o">=</span> <span class="n">checkpoint</span><span class="p">[</span><span class="s1">&#39;train_logs&#39;</span><span class="p">]</span>
    <span class="n">reprint_logs</span><span class="p">(</span><span class="n">train_logs</span><span class="p">,</span> <span class="n">print_freq</span><span class="o">=</span><span class="n">PRINT_FREQ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>CURRENTLY TRAINING: RESNET-34

Epoch [025/300]   Train   Loss=4.0574   Acc=2.15    Val   Loss=4.0820   Acc=1.26
Epoch [050/300]   Train   Loss=3.9758   Acc=2.69    Val   Loss=3.9862   Acc=2.09
Epoch [075/300]   Train   Loss=3.8053   Acc=5.10    Val   Loss=4.0809   Acc=1.67
Epoch [100/300]   Train   Loss=3.2984   Acc=13.16    Val   Loss=4.5070   Acc=3.77
Epoch [125/300]   Train   Loss=2.2521   Acc=31.60    Val   Loss=3.6764   Acc=12.55
Epoch [150/300]   Train   Loss=0.7602   Acc=80.30    Val   Loss=3.2482   Acc=20.08
Epoch [175/300]   Train   Loss=0.1582   Acc=98.30    Val   Loss=0.6869   Acc=80.33
Epoch [200/300]   Train   Loss=0.0672   Acc=99.55    Val   Loss=0.2090   Acc=97.07
Epoch [225/300]   Train   Loss=0.0402   Acc=99.91    Val   Loss=0.0632   Acc=100.00
Epoch [250/300]   Train   Loss=0.0293   Acc=99.91    Val   Loss=0.0613   Acc=100.00
Epoch [275/300]   Train   Loss=0.0234   Acc=100.00    Val   Loss=0.0460   Acc=100.00
Epoch [300/300]   Train   Loss=0.0204   Acc=100.00    Val   Loss=0.0403   Acc=100.00



CURRENTLY TRAINING: RESNET-50

Epoch [025/300]   Train   Loss=4.0678   Acc=2.42    Val   Loss=4.2562   Acc=0.42
Epoch [050/300]   Train   Loss=4.0441   Acc=1.97    Val   Loss=4.1825   Acc=0.42
Epoch [075/300]   Train   Loss=3.9794   Acc=3.76    Val   Loss=4.0510   Acc=1.26
Epoch [100/300]   Train   Loss=3.8579   Acc=3.58    Val   Loss=4.1243   Acc=4.18
Epoch [125/300]   Train   Loss=3.7007   Acc=6.36    Val   Loss=3.8459   Acc=5.44
Epoch [150/300]   Train   Loss=3.3561   Acc=12.44    Val   Loss=4.1421   Acc=7.95
Epoch [175/300]   Train   Loss=2.7279   Acc=20.77    Val   Loss=4.6280   Acc=12.13
Epoch [200/300]   Train   Loss=1.7716   Acc=46.02    Val   Loss=2.4929   Acc=32.64
Epoch [225/300]   Train   Loss=0.8976   Acc=74.66    Val   Loss=1.1858   Acc=60.67
Epoch [250/300]   Train   Loss=0.4188   Acc=91.67    Val   Loss=0.5438   Acc=86.19
Epoch [275/300]   Train   Loss=0.2002   Acc=98.12    Val   Loss=0.3079   Acc=95.40
Epoch [300/300]   Train   Loss=0.1587   Acc=98.93    Val   Loss=0.3080   Acc=97.49



CURRENTLY TRAINING: RESNET-101

Epoch [025/300]   Train   Loss=4.0725   Acc=1.97    Val   Loss=4.0757   Acc=2.51
Epoch [050/300]   Train   Loss=4.0537   Acc=2.24    Val   Loss=4.0807   Acc=0.00
Epoch [075/300]   Train   Loss=4.0373   Acc=2.51    Val   Loss=4.4942   Acc=0.00
Epoch [100/300]   Train   Loss=4.0092   Acc=2.69    Val   Loss=4.1637   Acc=0.84
Epoch [125/300]   Train   Loss=3.9301   Acc=3.22    Val   Loss=4.0554   Acc=2.09
Epoch [150/300]   Train   Loss=3.8047   Acc=4.92    Val   Loss=3.8728   Acc=4.60
Epoch [175/300]   Train   Loss=3.5542   Acc=8.24    Val   Loss=5.0416   Acc=6.69
Epoch [200/300]   Train   Loss=2.9680   Acc=19.07    Val   Loss=3.4382   Acc=10.88
Epoch [225/300]   Train   Loss=2.0629   Acc=38.94    Val   Loss=2.9192   Acc=23.85
Epoch [250/300]   Train   Loss=1.0878   Acc=69.65    Val   Loss=1.4684   Acc=55.65
Epoch [275/300]   Train   Loss=0.5059   Acc=90.69    Val   Loss=0.7582   Acc=83.26
Epoch [300/300]   Train   Loss=0.3580   Acc=95.17    Val   Loss=0.5750   Acc=89.12



CURRENTLY TRAINING: RESNET-152

Epoch [025/300]   Train   Loss=4.0585   Acc=2.24    Val   Loss=4.9067   Acc=0.42
Epoch [050/300]   Train   Loss=4.0482   Acc=2.33    Val   Loss=4.0833   Acc=0.00
Epoch [075/300]   Train   Loss=4.0430   Acc=2.51    Val   Loss=4.2981   Acc=0.42
Epoch [100/300]   Train   Loss=3.9630   Acc=3.49    Val   Loss=4.2139   Acc=0.00
Epoch [125/300]   Train   Loss=3.8397   Acc=4.66    Val   Loss=3.9156   Acc=3.77
Epoch [150/300]   Train   Loss=3.6058   Acc=5.91    Val   Loss=3.7754   Acc=2.09
Epoch [175/300]   Train   Loss=3.3081   Acc=10.56    Val   Loss=4.0100   Acc=9.62
Epoch [200/300]   Train   Loss=2.9729   Acc=15.58    Val   Loss=8.9314   Acc=14.23
Epoch [225/300]   Train   Loss=2.4235   Acc=26.68    Val   Loss=4.5888   Acc=19.67
Epoch [250/300]   Train   Loss=1.6847   Acc=47.36    Val   Loss=5.1873   Acc=29.71
Epoch [275/300]   Train   Loss=1.0409   Acc=70.37    Val   Loss=3.1370   Acc=57.32
Epoch [300/300]   Train   Loss=0.7877   Acc=81.11    Val   Loss=1.3156   Acc=68.20
</pre></div>
</div>
</div>
</div>
<p>Judging from the messages printed during training, we observe a similar pattern for all ResNet architectures: Training progresses very slowly at the beginning (i.e., training loss decreases only incrementally). Once the loss drops below <span class="math notranslate nohighlight">\(4.0\)</span>, it tends to decrease close to <span class="math notranslate nohighlight">\(0\)</span> very quickly. What we notice is that, for some architectures, this point of dropping below <span class="math notranslate nohighlight">\(4.0\)</span> seems to happen a bit <em>too late</em> so that the model does not reach a very high accuracy within <span class="math notranslate nohighlight">\(300\)</span> epochs of training. However, from this single run of training the different models, we cannot infer that the deeper ResNet models are less suited to our task. Instead, it <em>does seem</em> that all of the models would reach near-perfect accuracy if the training duration (i.e., number of epochs) was adjusted accordingly, and that the speed at which the models reach near-perfect accuracy depends on the size of the model (i.e., the number of parameters), which makes perfect sense.</p>
<p><strong>Note</strong>: While we did set a random seed, this still doesn’t set up a level playing field across models of different depths, since these have different numbers of parameters that need to be initialized randomly!</p>
<p>Finally, let’s <strong>plot the training results</strong> so we can take another look at them!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Provide file paths to checkpoints</span>
<span class="n">checkpoints</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">18</span><span class="p">:</span> <span class="s1">&#39;resnet18/epoch-300_acc-99.5816.pt&#39;</span><span class="p">,</span>
    <span class="mi">34</span><span class="p">:</span> <span class="s1">&#39;resnet34/epoch-300_acc-100.0000.pt&#39;</span><span class="p">,</span>
    <span class="mi">50</span><span class="p">:</span> <span class="s1">&#39;resnet50/epoch-300_acc-97.4895.pt&#39;</span><span class="p">,</span>
    <span class="mi">101</span><span class="p">:</span> <span class="s1">&#39;resnet101/epoch-300_acc-89.1213.pt&#39;</span><span class="p">,</span>
    <span class="mi">152</span><span class="p">:</span> <span class="s1">&#39;resnet152/epoch-300_acc-68.2008.pt&#39;</span>
    <span class="p">}</span>

<span class="c1"># Iteratively load training logs for all ResNet models</span>
<span class="n">resnet_train_logs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

<span class="k">for</span> <span class="n">depth</span><span class="p">,</span> <span class="n">checkpoint_path</span> <span class="ow">in</span> <span class="n">checkpoints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">checkpoint</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
        <span class="n">MODELS_DIR</span> <span class="o">/</span> <span class="n">checkpoint_path</span><span class="p">,</span>
        <span class="n">map_location</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span>
        <span class="p">)</span>
    <span class="n">resnet_train_logs</span><span class="p">[</span><span class="n">depth</span><span class="p">]</span> <span class="o">=</span> <span class="n">checkpoint</span><span class="p">[</span><span class="s1">&#39;train_logs&#39;</span><span class="p">]</span>

<span class="c1"># Plot (training) loss and accuracy of all models</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;reports/figures/results/resnet-comparison.png&#39;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>  <span class="c1"># loss (i=0) and accuracy (i=1)</span>
    <span class="k">for</span> <span class="n">depth</span><span class="p">,</span> <span class="n">train_logs</span> <span class="ow">in</span> <span class="n">resnet_train_logs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">logs</span> <span class="o">=</span> <span class="n">train_logs</span><span class="p">[</span><span class="s1">&#39;train_loss&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">train_logs</span><span class="p">[</span><span class="s1">&#39;train_acc&#39;</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">logs</span><span class="p">)),</span> <span class="n">logs</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;ResNet-</span><span class="si">{</span><span class="n">depth</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Epoch&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Loss&#39;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;Accuracy (in %)&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Training loss&#39;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;Training accuracy&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;major&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#DDDDDD&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;minor&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#EEEEEE&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">minorticks_on</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Comparing ResNet Models of Different Depths&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">file_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/55cdb91e1653ad4196ee28b5e4227dab9ea58272d102378a14b8037b105bfbf9.png" src="../../_images/55cdb91e1653ad4196ee28b5e4227dab9ea58272d102378a14b8037b105bfbf9.png" />
</div>
</div>
<p>What we see here confirms what we have already inferred from the regular print-outs during training: <strong>All of the models seem capable of learning to solve the task with near-perfect accuracy.</strong> Also, there seems to be a threshold just around a training loss of <span class="math notranslate nohighlight">\(4.0\)</span>. Once the loss drops below this value, it decreases exponentially. This effect <em>seems to be</em> slightly less pronounced for the larger models (i.e., ResNet-50, ResNet-101, and ResNet-152). However, this is likely due to the REX learning rate scheduler that we have implemented, which drives the learning rate towards <span class="math notranslate nohighlight">\(0\)</span> at the end of the 300 training epochs. Loosely speaking, once the larger models figured out <em>where to go</em>, it was already too late. Nevertheless, based on the data plotted above, it seems <em>highly likely</em> that we could’ve also achieved near-perfect accuracy with the deeper ResNet models had we trained them for more epochs.</p>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./notebooks/student_projects"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="../assignments/optimisation_learning.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">A3. Optimisation and Learning</p>
      </div>
    </a>
    <a class="right-next"
       href="../python_course/beginners.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Python For Beginners</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#preparation">Preparation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#importing-packages">Importing Packages</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#downloading-checkpoints">Downloading Checkpoints</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-card-game-dobble-and-projective-planes">The Card Game Dobble and Projective Planes</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lines-in-the-euclidean-plane">Lines in the Euclidean Plane</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#adding-points-at-infinity">Adding Points at Infinity</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#finite-projective-planes-and-incidence-matrices">Finite Projective Planes and Incidence Matrices</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#further-reading">Further Reading</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-our-own-dobble-playing-cards">Creating our own Dobble Playing Cards</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#empty-playing-cards">Empty Playing Cards</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#emojis">Emojis</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#circle-packing">Circle Packing</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#finite-projective-planes">Finite Projective Planes</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dobble-decks">Dobble Decks</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pairs-of-cards">Pairs of Cards</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#setting-up-a-deep-learning-pipeline">Setting up a Deep Learning Pipeline</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#generating-datasets">Generating Datasets</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#utility-functions">Utility Functions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#learning-rate-schedule-rex">Learning Rate Schedule REX</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#training-and-testing-routines">Training and Testing Routines</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#transforming-and-augmenting-images">Transforming and Augmenting Images</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#resnet-models-of-different-depths">ResNet Models of Different Depths</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#parameters-and-preparation">Parameters and Preparation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#resnet-18">ResNet-18</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#remaining-resnet-models">Remaining ResNet Models</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Arash Akbarinia
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>